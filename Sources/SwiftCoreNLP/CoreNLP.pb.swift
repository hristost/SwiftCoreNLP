// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: CoreNLP.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///
/// An enumeration for the valid languages allowed in CoreNLP
public enum Edu_Stanford_Nlp_Pipeline_Language: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0
  case any // = 1
  case arabic // = 2
  case chinese // = 3
  case english // = 4
  case german // = 5
  case french // = 6
  case hebrew // = 7
  case spanish // = 8
  case universalEnglish // = 9
  case universalChinese // = 10

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .any
    case 2: self = .arabic
    case 3: self = .chinese
    case 4: self = .english
    case 5: self = .german
    case 6: self = .french
    case 7: self = .hebrew
    case 8: self = .spanish
    case 9: self = .universalEnglish
    case 10: self = .universalChinese
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .any: return 1
    case .arabic: return 2
    case .chinese: return 3
    case .english: return 4
    case .german: return 5
    case .french: return 6
    case .hebrew: return 7
    case .spanish: return 8
    case .universalEnglish: return 9
    case .universalChinese: return 10
    }
  }

}

#if swift(>=4.2)

extension Edu_Stanford_Nlp_Pipeline_Language: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

///
/// An enumeration of valid sentiment values for the sentiment classifier.
public enum Edu_Stanford_Nlp_Pipeline_Sentiment: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case strongNegative // = 0
  case weakNegative // = 1
  case neutral // = 2
  case weakPositive // = 3
  case strongPositive // = 4

  public init() {
    self = .strongNegative
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .strongNegative
    case 1: self = .weakNegative
    case 2: self = .neutral
    case 3: self = .weakPositive
    case 4: self = .strongPositive
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .strongNegative: return 0
    case .weakNegative: return 1
    case .neutral: return 2
    case .weakPositive: return 3
    case .strongPositive: return 4
    }
  }

}

#if swift(>=4.2)

extension Edu_Stanford_Nlp_Pipeline_Sentiment: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

///
/// The seven informative Natural Logic relations
public enum Edu_Stanford_Nlp_Pipeline_NaturalLogicRelation: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case equivalence // = 0
  case forwardEntailment // = 1
  case reverseEntailment // = 2
  case negation // = 3
  case alternation // = 4
  case cover // = 5
  case independence // = 6

  public init() {
    self = .equivalence
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .equivalence
    case 1: self = .forwardEntailment
    case 2: self = .reverseEntailment
    case 3: self = .negation
    case 4: self = .alternation
    case 5: self = .cover
    case 6: self = .independence
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .equivalence: return 0
    case .forwardEntailment: return 1
    case .reverseEntailment: return 2
    case .negation: return 3
    case .alternation: return 4
    case .cover: return 5
    case .independence: return 6
    }
  }

}

#if swift(>=4.2)

extension Edu_Stanford_Nlp_Pipeline_NaturalLogicRelation: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

///
/// A document; that is, the equivalent of an Annotation.
public struct Edu_Stanford_Nlp_Pipeline_Document: SwiftProtobuf.ExtensibleMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var text: String {
    get {return _storage._text ?? String()}
    set {_uniqueStorage()._text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  public var hasText: Bool {return _storage._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  public mutating func clearText() {_uniqueStorage()._text = nil}

  public var sentence: [Edu_Stanford_Nlp_Pipeline_Sentence] {
    get {return _storage._sentence}
    set {_uniqueStorage()._sentence = newValue}
  }

  public var corefChain: [Edu_Stanford_Nlp_Pipeline_CorefChain] {
    get {return _storage._corefChain}
    set {_uniqueStorage()._corefChain = newValue}
  }

  public var docID: String {
    get {return _storage._docID ?? String()}
    set {_uniqueStorage()._docID = newValue}
  }
  /// Returns true if `docID` has been explicitly set.
  public var hasDocID: Bool {return _storage._docID != nil}
  /// Clears the value of `docID`. Subsequent reads from it will return its default value.
  public mutating func clearDocID() {_uniqueStorage()._docID = nil}

  public var docDate: String {
    get {return _storage._docDate ?? String()}
    set {_uniqueStorage()._docDate = newValue}
  }
  /// Returns true if `docDate` has been explicitly set.
  public var hasDocDate: Bool {return _storage._docDate != nil}
  /// Clears the value of `docDate`. Subsequent reads from it will return its default value.
  public mutating func clearDocDate() {_uniqueStorage()._docDate = nil}

  public var calendar: UInt64 {
    get {return _storage._calendar ?? 0}
    set {_uniqueStorage()._calendar = newValue}
  }
  /// Returns true if `calendar` has been explicitly set.
  public var hasCalendar: Bool {return _storage._calendar != nil}
  /// Clears the value of `calendar`. Subsequent reads from it will return its default value.
  public mutating func clearCalendar() {_uniqueStorage()._calendar = nil}

  ///*
  /// A peculiar field, for the corner case when a Document is
  /// serialized without any sentences. Otherwise
  public var sentencelessToken: [Edu_Stanford_Nlp_Pipeline_Token] {
    get {return _storage._sentencelessToken}
    set {_uniqueStorage()._sentencelessToken = newValue}
  }

  public var character: [Edu_Stanford_Nlp_Pipeline_Token] {
    get {return _storage._character}
    set {_uniqueStorage()._character = newValue}
  }

  public var quote: [Edu_Stanford_Nlp_Pipeline_Quote] {
    get {return _storage._quote}
    set {_uniqueStorage()._quote = newValue}
  }

  ///*
  /// This field is for entity mentions across the document.
  public var mentions: [Edu_Stanford_Nlp_Pipeline_NERMention] {
    get {return _storage._mentions}
    set {_uniqueStorage()._mentions = newValue}
  }

  /// used to differentiate between null and empty list
  public var hasEntityMentionsAnnotation_p: Bool {
    get {return _storage._hasEntityMentionsAnnotation_p ?? false}
    set {_uniqueStorage()._hasEntityMentionsAnnotation_p = newValue}
  }
  /// Returns true if `hasEntityMentionsAnnotation_p` has been explicitly set.
  public var hasHasEntityMentionsAnnotation_p: Bool {return _storage._hasEntityMentionsAnnotation_p != nil}
  /// Clears the value of `hasEntityMentionsAnnotation_p`. Subsequent reads from it will return its default value.
  public mutating func clearHasEntityMentionsAnnotation_p() {_uniqueStorage()._hasEntityMentionsAnnotation_p = nil}

  ///*
  /// xml information
  public var xmlDoc: Bool {
    get {return _storage._xmlDoc ?? false}
    set {_uniqueStorage()._xmlDoc = newValue}
  }
  /// Returns true if `xmlDoc` has been explicitly set.
  public var hasXmlDoc: Bool {return _storage._xmlDoc != nil}
  /// Clears the value of `xmlDoc`. Subsequent reads from it will return its default value.
  public mutating func clearXmlDoc() {_uniqueStorage()._xmlDoc = nil}

  public var sections: [Edu_Stanford_Nlp_Pipeline_Section] {
    get {return _storage._sections}
    set {_uniqueStorage()._sections = newValue}
  }

  ///* coref mentions for entire document *
  public var mentionsForCoref: [Edu_Stanford_Nlp_Pipeline_Mention] {
    get {return _storage._mentionsForCoref}
    set {_uniqueStorage()._mentionsForCoref = newValue}
  }

  public var hasCorefMentionAnnotation_p: Bool {
    get {return _storage._hasCorefMentionAnnotation_p ?? false}
    set {_uniqueStorage()._hasCorefMentionAnnotation_p = newValue}
  }
  /// Returns true if `hasCorefMentionAnnotation_p` has been explicitly set.
  public var hasHasCorefMentionAnnotation_p: Bool {return _storage._hasCorefMentionAnnotation_p != nil}
  /// Clears the value of `hasCorefMentionAnnotation_p`. Subsequent reads from it will return its default value.
  public mutating func clearHasCorefMentionAnnotation_p() {_uniqueStorage()._hasCorefMentionAnnotation_p = nil}

  public var hasCorefAnnotation_p: Bool {
    get {return _storage._hasCorefAnnotation_p ?? false}
    set {_uniqueStorage()._hasCorefAnnotation_p = newValue}
  }
  /// Returns true if `hasCorefAnnotation_p` has been explicitly set.
  public var hasHasCorefAnnotation_p: Bool {return _storage._hasCorefAnnotation_p != nil}
  /// Clears the value of `hasCorefAnnotation_p`. Subsequent reads from it will return its default value.
  public mutating func clearHasCorefAnnotation_p() {_uniqueStorage()._hasCorefAnnotation_p = nil}

  public var corefMentionToEntityMentionMappings: [Int32] {
    get {return _storage._corefMentionToEntityMentionMappings}
    set {_uniqueStorage()._corefMentionToEntityMentionMappings = newValue}
  }

  public var entityMentionToCorefMentionMappings: [Int32] {
    get {return _storage._entityMentionToCorefMentionMappings}
    set {_uniqueStorage()._entityMentionToCorefMentionMappings = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  public var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _storage = _StorageClass.defaultInstance
}

///
/// The serialized version of a CoreMap representing a sentence.
public struct Edu_Stanford_Nlp_Pipeline_Sentence: SwiftProtobuf.ExtensibleMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: [Edu_Stanford_Nlp_Pipeline_Token] {
    get {return _storage._token}
    set {_uniqueStorage()._token = newValue}
  }

  public var tokenOffsetBegin: UInt32 {
    get {return _storage._tokenOffsetBegin ?? 0}
    set {_uniqueStorage()._tokenOffsetBegin = newValue}
  }
  /// Returns true if `tokenOffsetBegin` has been explicitly set.
  public var hasTokenOffsetBegin: Bool {return _storage._tokenOffsetBegin != nil}
  /// Clears the value of `tokenOffsetBegin`. Subsequent reads from it will return its default value.
  public mutating func clearTokenOffsetBegin() {_uniqueStorage()._tokenOffsetBegin = nil}

  public var tokenOffsetEnd: UInt32 {
    get {return _storage._tokenOffsetEnd ?? 0}
    set {_uniqueStorage()._tokenOffsetEnd = newValue}
  }
  /// Returns true if `tokenOffsetEnd` has been explicitly set.
  public var hasTokenOffsetEnd: Bool {return _storage._tokenOffsetEnd != nil}
  /// Clears the value of `tokenOffsetEnd`. Subsequent reads from it will return its default value.
  public mutating func clearTokenOffsetEnd() {_uniqueStorage()._tokenOffsetEnd = nil}

  public var sentenceIndex: UInt32 {
    get {return _storage._sentenceIndex ?? 0}
    set {_uniqueStorage()._sentenceIndex = newValue}
  }
  /// Returns true if `sentenceIndex` has been explicitly set.
  public var hasSentenceIndex: Bool {return _storage._sentenceIndex != nil}
  /// Clears the value of `sentenceIndex`. Subsequent reads from it will return its default value.
  public mutating func clearSentenceIndex() {_uniqueStorage()._sentenceIndex = nil}

  public var characterOffsetBegin: UInt32 {
    get {return _storage._characterOffsetBegin ?? 0}
    set {_uniqueStorage()._characterOffsetBegin = newValue}
  }
  /// Returns true if `characterOffsetBegin` has been explicitly set.
  public var hasCharacterOffsetBegin: Bool {return _storage._characterOffsetBegin != nil}
  /// Clears the value of `characterOffsetBegin`. Subsequent reads from it will return its default value.
  public mutating func clearCharacterOffsetBegin() {_uniqueStorage()._characterOffsetBegin = nil}

  public var characterOffsetEnd: UInt32 {
    get {return _storage._characterOffsetEnd ?? 0}
    set {_uniqueStorage()._characterOffsetEnd = newValue}
  }
  /// Returns true if `characterOffsetEnd` has been explicitly set.
  public var hasCharacterOffsetEnd: Bool {return _storage._characterOffsetEnd != nil}
  /// Clears the value of `characterOffsetEnd`. Subsequent reads from it will return its default value.
  public mutating func clearCharacterOffsetEnd() {_uniqueStorage()._characterOffsetEnd = nil}

  public var parseTree: Edu_Stanford_Nlp_Pipeline_ParseTree {
    get {return _storage._parseTree ?? Edu_Stanford_Nlp_Pipeline_ParseTree()}
    set {_uniqueStorage()._parseTree = newValue}
  }
  /// Returns true if `parseTree` has been explicitly set.
  public var hasParseTree: Bool {return _storage._parseTree != nil}
  /// Clears the value of `parseTree`. Subsequent reads from it will return its default value.
  public mutating func clearParseTree() {_uniqueStorage()._parseTree = nil}

  public var binarizedParseTree: Edu_Stanford_Nlp_Pipeline_ParseTree {
    get {return _storage._binarizedParseTree ?? Edu_Stanford_Nlp_Pipeline_ParseTree()}
    set {_uniqueStorage()._binarizedParseTree = newValue}
  }
  /// Returns true if `binarizedParseTree` has been explicitly set.
  public var hasBinarizedParseTree: Bool {return _storage._binarizedParseTree != nil}
  /// Clears the value of `binarizedParseTree`. Subsequent reads from it will return its default value.
  public mutating func clearBinarizedParseTree() {_uniqueStorage()._binarizedParseTree = nil}

  public var annotatedParseTree: Edu_Stanford_Nlp_Pipeline_ParseTree {
    get {return _storage._annotatedParseTree ?? Edu_Stanford_Nlp_Pipeline_ParseTree()}
    set {_uniqueStorage()._annotatedParseTree = newValue}
  }
  /// Returns true if `annotatedParseTree` has been explicitly set.
  public var hasAnnotatedParseTree: Bool {return _storage._annotatedParseTree != nil}
  /// Clears the value of `annotatedParseTree`. Subsequent reads from it will return its default value.
  public mutating func clearAnnotatedParseTree() {_uniqueStorage()._annotatedParseTree = nil}

  public var sentiment: String {
    get {return _storage._sentiment ?? String()}
    set {_uniqueStorage()._sentiment = newValue}
  }
  /// Returns true if `sentiment` has been explicitly set.
  public var hasSentiment: Bool {return _storage._sentiment != nil}
  /// Clears the value of `sentiment`. Subsequent reads from it will return its default value.
  public mutating func clearSentiment() {_uniqueStorage()._sentiment = nil}

  public var kBestParseTrees: [Edu_Stanford_Nlp_Pipeline_ParseTree] {
    get {return _storage._kBestParseTrees}
    set {_uniqueStorage()._kBestParseTrees = newValue}
  }

  public var basicDependencies: Edu_Stanford_Nlp_Pipeline_DependencyGraph {
    get {return _storage._basicDependencies ?? Edu_Stanford_Nlp_Pipeline_DependencyGraph()}
    set {_uniqueStorage()._basicDependencies = newValue}
  }
  /// Returns true if `basicDependencies` has been explicitly set.
  public var hasBasicDependencies: Bool {return _storage._basicDependencies != nil}
  /// Clears the value of `basicDependencies`. Subsequent reads from it will return its default value.
  public mutating func clearBasicDependencies() {_uniqueStorage()._basicDependencies = nil}

  public var collapsedDependencies: Edu_Stanford_Nlp_Pipeline_DependencyGraph {
    get {return _storage._collapsedDependencies ?? Edu_Stanford_Nlp_Pipeline_DependencyGraph()}
    set {_uniqueStorage()._collapsedDependencies = newValue}
  }
  /// Returns true if `collapsedDependencies` has been explicitly set.
  public var hasCollapsedDependencies: Bool {return _storage._collapsedDependencies != nil}
  /// Clears the value of `collapsedDependencies`. Subsequent reads from it will return its default value.
  public mutating func clearCollapsedDependencies() {_uniqueStorage()._collapsedDependencies = nil}

  public var collapsedCcprocessedDependencies: Edu_Stanford_Nlp_Pipeline_DependencyGraph {
    get {return _storage._collapsedCcprocessedDependencies ?? Edu_Stanford_Nlp_Pipeline_DependencyGraph()}
    set {_uniqueStorage()._collapsedCcprocessedDependencies = newValue}
  }
  /// Returns true if `collapsedCcprocessedDependencies` has been explicitly set.
  public var hasCollapsedCcprocessedDependencies: Bool {return _storage._collapsedCcprocessedDependencies != nil}
  /// Clears the value of `collapsedCcprocessedDependencies`. Subsequent reads from it will return its default value.
  public mutating func clearCollapsedCcprocessedDependencies() {_uniqueStorage()._collapsedCcprocessedDependencies = nil}

  public var alternativeDependencies: Edu_Stanford_Nlp_Pipeline_DependencyGraph {
    get {return _storage._alternativeDependencies ?? Edu_Stanford_Nlp_Pipeline_DependencyGraph()}
    set {_uniqueStorage()._alternativeDependencies = newValue}
  }
  /// Returns true if `alternativeDependencies` has been explicitly set.
  public var hasAlternativeDependencies: Bool {return _storage._alternativeDependencies != nil}
  /// Clears the value of `alternativeDependencies`. Subsequent reads from it will return its default value.
  public mutating func clearAlternativeDependencies() {_uniqueStorage()._alternativeDependencies = nil}

  /// The OpenIE triples in the sentence
  public var openieTriple: [Edu_Stanford_Nlp_Pipeline_RelationTriple] {
    get {return _storage._openieTriple}
    set {_uniqueStorage()._openieTriple = newValue}
  }

  /// The KBP triples in this sentence
  public var kbpTriple: [Edu_Stanford_Nlp_Pipeline_RelationTriple] {
    get {return _storage._kbpTriple}
    set {_uniqueStorage()._kbpTriple = newValue}
  }

  /// The entailed sentences, by natural logic
  public var entailedSentence: [Edu_Stanford_Nlp_Pipeline_SentenceFragment] {
    get {return _storage._entailedSentence}
    set {_uniqueStorage()._entailedSentence = newValue}
  }

  /// The entailed clauses, by natural logic
  public var entailedClause: [Edu_Stanford_Nlp_Pipeline_SentenceFragment] {
    get {return _storage._entailedClause}
    set {_uniqueStorage()._entailedClause = newValue}
  }

  public var enhancedDependencies: Edu_Stanford_Nlp_Pipeline_DependencyGraph {
    get {return _storage._enhancedDependencies ?? Edu_Stanford_Nlp_Pipeline_DependencyGraph()}
    set {_uniqueStorage()._enhancedDependencies = newValue}
  }
  /// Returns true if `enhancedDependencies` has been explicitly set.
  public var hasEnhancedDependencies: Bool {return _storage._enhancedDependencies != nil}
  /// Clears the value of `enhancedDependencies`. Subsequent reads from it will return its default value.
  public mutating func clearEnhancedDependencies() {_uniqueStorage()._enhancedDependencies = nil}

  public var enhancedPlusPlusDependencies: Edu_Stanford_Nlp_Pipeline_DependencyGraph {
    get {return _storage._enhancedPlusPlusDependencies ?? Edu_Stanford_Nlp_Pipeline_DependencyGraph()}
    set {_uniqueStorage()._enhancedPlusPlusDependencies = newValue}
  }
  /// Returns true if `enhancedPlusPlusDependencies` has been explicitly set.
  public var hasEnhancedPlusPlusDependencies: Bool {return _storage._enhancedPlusPlusDependencies != nil}
  /// Clears the value of `enhancedPlusPlusDependencies`. Subsequent reads from it will return its default value.
  public mutating func clearEnhancedPlusPlusDependencies() {_uniqueStorage()._enhancedPlusPlusDependencies = nil}

  public var character: [Edu_Stanford_Nlp_Pipeline_Token] {
    get {return _storage._character}
    set {_uniqueStorage()._character = newValue}
  }

  public var paragraph: UInt32 {
    get {return _storage._paragraph ?? 0}
    set {_uniqueStorage()._paragraph = newValue}
  }
  /// Returns true if `paragraph` has been explicitly set.
  public var hasParagraph: Bool {return _storage._paragraph != nil}
  /// Clears the value of `paragraph`. Subsequent reads from it will return its default value.
  public mutating func clearParagraph() {_uniqueStorage()._paragraph = nil}

  /// Only needed if we're only saving the sentence.
  public var text: String {
    get {return _storage._text ?? String()}
    set {_uniqueStorage()._text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  public var hasText: Bool {return _storage._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  public mutating func clearText() {_uniqueStorage()._text = nil}

  public var lineNumber: UInt32 {
    get {return _storage._lineNumber ?? 0}
    set {_uniqueStorage()._lineNumber = newValue}
  }
  /// Returns true if `lineNumber` has been explicitly set.
  public var hasLineNumber: Bool {return _storage._lineNumber != nil}
  /// Clears the value of `lineNumber`. Subsequent reads from it will return its default value.
  public mutating func clearLineNumber() {_uniqueStorage()._lineNumber = nil}

  /// Fields set by other annotators in CoreNLP
  public var hasRelationAnnotations_p: Bool {
    get {return _storage._hasRelationAnnotations_p ?? false}
    set {_uniqueStorage()._hasRelationAnnotations_p = newValue}
  }
  /// Returns true if `hasRelationAnnotations_p` has been explicitly set.
  public var hasHasRelationAnnotations_p: Bool {return _storage._hasRelationAnnotations_p != nil}
  /// Clears the value of `hasRelationAnnotations_p`. Subsequent reads from it will return its default value.
  public mutating func clearHasRelationAnnotations_p() {_uniqueStorage()._hasRelationAnnotations_p = nil}

  public var entity: [Edu_Stanford_Nlp_Pipeline_Entity] {
    get {return _storage._entity}
    set {_uniqueStorage()._entity = newValue}
  }

  public var relation: [Edu_Stanford_Nlp_Pipeline_Relation] {
    get {return _storage._relation}
    set {_uniqueStorage()._relation = newValue}
  }

  public var hasNumerizedTokensAnnotation_p: Bool {
    get {return _storage._hasNumerizedTokensAnnotation_p ?? false}
    set {_uniqueStorage()._hasNumerizedTokensAnnotation_p = newValue}
  }
  /// Returns true if `hasNumerizedTokensAnnotation_p` has been explicitly set.
  public var hasHasNumerizedTokensAnnotation_p: Bool {return _storage._hasNumerizedTokensAnnotation_p != nil}
  /// Clears the value of `hasNumerizedTokensAnnotation_p`. Subsequent reads from it will return its default value.
  public mutating func clearHasNumerizedTokensAnnotation_p() {_uniqueStorage()._hasNumerizedTokensAnnotation_p = nil}

  public var mentions: [Edu_Stanford_Nlp_Pipeline_NERMention] {
    get {return _storage._mentions}
    set {_uniqueStorage()._mentions = newValue}
  }

  public var mentionsForCoref: [Edu_Stanford_Nlp_Pipeline_Mention] {
    get {return _storage._mentionsForCoref}
    set {_uniqueStorage()._mentionsForCoref = newValue}
  }

  public var hasCorefMentionsAnnotation_p: Bool {
    get {return _storage._hasCorefMentionsAnnotation_p ?? false}
    set {_uniqueStorage()._hasCorefMentionsAnnotation_p = newValue}
  }
  /// Returns true if `hasCorefMentionsAnnotation_p` has been explicitly set.
  public var hasHasCorefMentionsAnnotation_p: Bool {return _storage._hasCorefMentionsAnnotation_p != nil}
  /// Clears the value of `hasCorefMentionsAnnotation_p`. Subsequent reads from it will return its default value.
  public mutating func clearHasCorefMentionsAnnotation_p() {_uniqueStorage()._hasCorefMentionsAnnotation_p = nil}

  /// Useful when storing sentences (e.g. ForEach)
  public var sentenceID: String {
    get {return _storage._sentenceID ?? String()}
    set {_uniqueStorage()._sentenceID = newValue}
  }
  /// Returns true if `sentenceID` has been explicitly set.
  public var hasSentenceID: Bool {return _storage._sentenceID != nil}
  /// Clears the value of `sentenceID`. Subsequent reads from it will return its default value.
  public mutating func clearSentenceID() {_uniqueStorage()._sentenceID = nil}

  /// date of section
  public var sectionDate: String {
    get {return _storage._sectionDate ?? String()}
    set {_uniqueStorage()._sectionDate = newValue}
  }
  /// Returns true if `sectionDate` has been explicitly set.
  public var hasSectionDate: Bool {return _storage._sectionDate != nil}
  /// Clears the value of `sectionDate`. Subsequent reads from it will return its default value.
  public mutating func clearSectionDate() {_uniqueStorage()._sectionDate = nil}

  /// section index for this sentence's section
  public var sectionIndex: UInt32 {
    get {return _storage._sectionIndex ?? 0}
    set {_uniqueStorage()._sectionIndex = newValue}
  }
  /// Returns true if `sectionIndex` has been explicitly set.
  public var hasSectionIndex: Bool {return _storage._sectionIndex != nil}
  /// Clears the value of `sectionIndex`. Subsequent reads from it will return its default value.
  public mutating func clearSectionIndex() {_uniqueStorage()._sectionIndex = nil}

  /// name of section
  public var sectionName: String {
    get {return _storage._sectionName ?? String()}
    set {_uniqueStorage()._sectionName = newValue}
  }
  /// Returns true if `sectionName` has been explicitly set.
  public var hasSectionName: Bool {return _storage._sectionName != nil}
  /// Clears the value of `sectionName`. Subsequent reads from it will return its default value.
  public mutating func clearSectionName() {_uniqueStorage()._sectionName = nil}

  /// author of section
  public var sectionAuthor: String {
    get {return _storage._sectionAuthor ?? String()}
    set {_uniqueStorage()._sectionAuthor = newValue}
  }
  /// Returns true if `sectionAuthor` has been explicitly set.
  public var hasSectionAuthor: Bool {return _storage._sectionAuthor != nil}
  /// Clears the value of `sectionAuthor`. Subsequent reads from it will return its default value.
  public mutating func clearSectionAuthor() {_uniqueStorage()._sectionAuthor = nil}

  /// doc id
  public var docID: String {
    get {return _storage._docID ?? String()}
    set {_uniqueStorage()._docID = newValue}
  }
  /// Returns true if `docID` has been explicitly set.
  public var hasDocID: Bool {return _storage._docID != nil}
  /// Clears the value of `docID`. Subsequent reads from it will return its default value.
  public mutating func clearDocID() {_uniqueStorage()._docID = nil}

  /// is this sentence in an xml quote in a post
  public var sectionQuoted: Bool {
    get {return _storage._sectionQuoted ?? false}
    set {_uniqueStorage()._sectionQuoted = newValue}
  }
  /// Returns true if `sectionQuoted` has been explicitly set.
  public var hasSectionQuoted: Bool {return _storage._sectionQuoted != nil}
  /// Clears the value of `sectionQuoted`. Subsequent reads from it will return its default value.
  public mutating func clearSectionQuoted() {_uniqueStorage()._sectionQuoted = nil}

  /// check if there are entity mentions
  public var hasEntityMentionsAnnotation_p: Bool {
    get {return _storage._hasEntityMentionsAnnotation_p ?? false}
    set {_uniqueStorage()._hasEntityMentionsAnnotation_p = newValue}
  }
  /// Returns true if `hasEntityMentionsAnnotation_p` has been explicitly set.
  public var hasHasEntityMentionsAnnotation_p: Bool {return _storage._hasEntityMentionsAnnotation_p != nil}
  /// Clears the value of `hasEntityMentionsAnnotation_p`. Subsequent reads from it will return its default value.
  public mutating func clearHasEntityMentionsAnnotation_p() {_uniqueStorage()._hasEntityMentionsAnnotation_p = nil}

  /// check if there are KBP triples
  public var hasKbptriplesAnnotation_p: Bool {
    get {return _storage._hasKbptriplesAnnotation_p ?? false}
    set {_uniqueStorage()._hasKbptriplesAnnotation_p = newValue}
  }
  /// Returns true if `hasKbptriplesAnnotation_p` has been explicitly set.
  public var hasHasKbptriplesAnnotation_p: Bool {return _storage._hasKbptriplesAnnotation_p != nil}
  /// Clears the value of `hasKbptriplesAnnotation_p`. Subsequent reads from it will return its default value.
  public mutating func clearHasKbptriplesAnnotation_p() {_uniqueStorage()._hasKbptriplesAnnotation_p = nil}

  /// check if there are OpenIE triples
  public var hasOpenieTriplesAnnotation_p: Bool {
    get {return _storage._hasOpenieTriplesAnnotation_p ?? false}
    set {_uniqueStorage()._hasOpenieTriplesAnnotation_p = newValue}
  }
  /// Returns true if `hasOpenieTriplesAnnotation_p` has been explicitly set.
  public var hasHasOpenieTriplesAnnotation_p: Bool {return _storage._hasOpenieTriplesAnnotation_p != nil}
  /// Clears the value of `hasOpenieTriplesAnnotation_p`. Subsequent reads from it will return its default value.
  public mutating func clearHasOpenieTriplesAnnotation_p() {_uniqueStorage()._hasOpenieTriplesAnnotation_p = nil}

  /// quote stuff
  public var chapterIndex: UInt32 {
    get {return _storage._chapterIndex ?? 0}
    set {_uniqueStorage()._chapterIndex = newValue}
  }
  /// Returns true if `chapterIndex` has been explicitly set.
  public var hasChapterIndex: Bool {return _storage._chapterIndex != nil}
  /// Clears the value of `chapterIndex`. Subsequent reads from it will return its default value.
  public mutating func clearChapterIndex() {_uniqueStorage()._chapterIndex = nil}

  public var paragraphIndex: UInt32 {
    get {return _storage._paragraphIndex ?? 0}
    set {_uniqueStorage()._paragraphIndex = newValue}
  }
  /// Returns true if `paragraphIndex` has been explicitly set.
  public var hasParagraphIndex: Bool {return _storage._paragraphIndex != nil}
  /// Clears the value of `paragraphIndex`. Subsequent reads from it will return its default value.
  public mutating func clearParagraphIndex() {_uniqueStorage()._paragraphIndex = nil}

  /// the quote annotator can soometimes add merged sentences
  public var enhancedSentence: Edu_Stanford_Nlp_Pipeline_Sentence {
    get {return _storage._enhancedSentence ?? Edu_Stanford_Nlp_Pipeline_Sentence()}
    set {_uniqueStorage()._enhancedSentence = newValue}
  }
  /// Returns true if `enhancedSentence` has been explicitly set.
  public var hasEnhancedSentence: Bool {return _storage._enhancedSentence != nil}
  /// Clears the value of `enhancedSentence`. Subsequent reads from it will return its default value.
  public mutating func clearEnhancedSentence() {_uniqueStorage()._enhancedSentence = nil}

  /// speaker stuff
  public var speaker: String {
    get {return _storage._speaker ?? String()}
    set {_uniqueStorage()._speaker = newValue}
  }
  /// Returns true if `speaker` has been explicitly set.
  public var hasSpeaker: Bool {return _storage._speaker != nil}
  /// Clears the value of `speaker`. Subsequent reads from it will return its default value.
  public mutating func clearSpeaker() {_uniqueStorage()._speaker = nil}

  /// The type of speaker speaking this sentence
  public var speakerType: String {
    get {return _storage._speakerType ?? String()}
    set {_uniqueStorage()._speakerType = newValue}
  }
  /// Returns true if `speakerType` has been explicitly set.
  public var hasSpeakerType: Bool {return _storage._speakerType != nil}
  /// Clears the value of `speakerType`. Subsequent reads from it will return its default value.
  public mutating func clearSpeakerType() {_uniqueStorage()._speakerType = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  public var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _storage = _StorageClass.defaultInstance
}

///
/// The serialized version of a Token (a CoreLabel).
public struct Edu_Stanford_Nlp_Pipeline_Token: SwiftProtobuf.ExtensibleMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Fields set by the default annotators [new CoreNLP(new Properties())]
  public var word: String {
    get {return _storage._word ?? String()}
    set {_uniqueStorage()._word = newValue}
  }
  /// Returns true if `word` has been explicitly set.
  public var hasWord: Bool {return _storage._word != nil}
  /// Clears the value of `word`. Subsequent reads from it will return its default value.
  public mutating func clearWord() {_uniqueStorage()._word = nil}

  /// The word's part of speech tag
  public var pos: String {
    get {return _storage._pos ?? String()}
    set {_uniqueStorage()._pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  public var hasPos: Bool {return _storage._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  public mutating func clearPos() {_uniqueStorage()._pos = nil}

  /// The word's 'value', (e.g., parse tree node)
  public var value: String {
    get {return _storage._value ?? String()}
    set {_uniqueStorage()._value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return _storage._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {_uniqueStorage()._value = nil}

  /// The word's 'category' (e.g., parse tree node)
  public var category: String {
    get {return _storage._category ?? String()}
    set {_uniqueStorage()._category = newValue}
  }
  /// Returns true if `category` has been explicitly set.
  public var hasCategory: Bool {return _storage._category != nil}
  /// Clears the value of `category`. Subsequent reads from it will return its default value.
  public mutating func clearCategory() {_uniqueStorage()._category = nil}

  /// The whitespace/xml before the token
  public var before: String {
    get {return _storage._before ?? String()}
    set {_uniqueStorage()._before = newValue}
  }
  /// Returns true if `before` has been explicitly set.
  public var hasBefore: Bool {return _storage._before != nil}
  /// Clears the value of `before`. Subsequent reads from it will return its default value.
  public mutating func clearBefore() {_uniqueStorage()._before = nil}

  /// The whitespace/xml after the token
  public var after: String {
    get {return _storage._after ?? String()}
    set {_uniqueStorage()._after = newValue}
  }
  /// Returns true if `after` has been explicitly set.
  public var hasAfter: Bool {return _storage._after != nil}
  /// Clears the value of `after`. Subsequent reads from it will return its default value.
  public mutating func clearAfter() {_uniqueStorage()._after = nil}

  /// The original text for this token
  public var originalText: String {
    get {return _storage._originalText ?? String()}
    set {_uniqueStorage()._originalText = newValue}
  }
  /// Returns true if `originalText` has been explicitly set.
  public var hasOriginalText: Bool {return _storage._originalText != nil}
  /// Clears the value of `originalText`. Subsequent reads from it will return its default value.
  public mutating func clearOriginalText() {_uniqueStorage()._originalText = nil}

  /// The word's NER tag
  public var ner: String {
    get {return _storage._ner ?? String()}
    set {_uniqueStorage()._ner = newValue}
  }
  /// Returns true if `ner` has been explicitly set.
  public var hasNer: Bool {return _storage._ner != nil}
  /// Clears the value of `ner`. Subsequent reads from it will return its default value.
  public mutating func clearNer() {_uniqueStorage()._ner = nil}

  /// The word's coarse NER tag
  public var coarseNer: String {
    get {return _storage._coarseNer ?? String()}
    set {_uniqueStorage()._coarseNer = newValue}
  }
  /// Returns true if `coarseNer` has been explicitly set.
  public var hasCoarseNer: Bool {return _storage._coarseNer != nil}
  /// Clears the value of `coarseNer`. Subsequent reads from it will return its default value.
  public mutating func clearCoarseNer() {_uniqueStorage()._coarseNer = nil}

  /// The word's fine-grained NER tag
  public var fineGrainedNer: String {
    get {return _storage._fineGrainedNer ?? String()}
    set {_uniqueStorage()._fineGrainedNer = newValue}
  }
  /// Returns true if `fineGrainedNer` has been explicitly set.
  public var hasFineGrainedNer: Bool {return _storage._fineGrainedNer != nil}
  /// Clears the value of `fineGrainedNer`. Subsequent reads from it will return its default value.
  public mutating func clearFineGrainedNer() {_uniqueStorage()._fineGrainedNer = nil}

  /// listing of probs
  public var nerLabelProbs: [String] {
    get {return _storage._nerLabelProbs}
    set {_uniqueStorage()._nerLabelProbs = newValue}
  }

  /// The word's normalized NER tag
  public var normalizedNer: String {
    get {return _storage._normalizedNer ?? String()}
    set {_uniqueStorage()._normalizedNer = newValue}
  }
  /// Returns true if `normalizedNer` has been explicitly set.
  public var hasNormalizedNer: Bool {return _storage._normalizedNer != nil}
  /// Clears the value of `normalizedNer`. Subsequent reads from it will return its default value.
  public mutating func clearNormalizedNer() {_uniqueStorage()._normalizedNer = nil}

  /// The word's lemma
  public var lemma: String {
    get {return _storage._lemma ?? String()}
    set {_uniqueStorage()._lemma = newValue}
  }
  /// Returns true if `lemma` has been explicitly set.
  public var hasLemma: Bool {return _storage._lemma != nil}
  /// Clears the value of `lemma`. Subsequent reads from it will return its default value.
  public mutating func clearLemma() {_uniqueStorage()._lemma = nil}

  /// The character offset begin, in the document
  public var beginChar: UInt32 {
    get {return _storage._beginChar ?? 0}
    set {_uniqueStorage()._beginChar = newValue}
  }
  /// Returns true if `beginChar` has been explicitly set.
  public var hasBeginChar: Bool {return _storage._beginChar != nil}
  /// Clears the value of `beginChar`. Subsequent reads from it will return its default value.
  public mutating func clearBeginChar() {_uniqueStorage()._beginChar = nil}

  /// The character offset end, in the document
  public var endChar: UInt32 {
    get {return _storage._endChar ?? 0}
    set {_uniqueStorage()._endChar = newValue}
  }
  /// Returns true if `endChar` has been explicitly set.
  public var hasEndChar: Bool {return _storage._endChar != nil}
  /// Clears the value of `endChar`. Subsequent reads from it will return its default value.
  public mutating func clearEndChar() {_uniqueStorage()._endChar = nil}

  /// The utterance tag used in dcoref
  public var utterance: UInt32 {
    get {return _storage._utterance ?? 0}
    set {_uniqueStorage()._utterance = newValue}
  }
  /// Returns true if `utterance` has been explicitly set.
  public var hasUtterance: Bool {return _storage._utterance != nil}
  /// Clears the value of `utterance`. Subsequent reads from it will return its default value.
  public mutating func clearUtterance() {_uniqueStorage()._utterance = nil}

  /// The speaker speaking this word
  public var speaker: String {
    get {return _storage._speaker ?? String()}
    set {_uniqueStorage()._speaker = newValue}
  }
  /// Returns true if `speaker` has been explicitly set.
  public var hasSpeaker: Bool {return _storage._speaker != nil}
  /// Clears the value of `speaker`. Subsequent reads from it will return its default value.
  public mutating func clearSpeaker() {_uniqueStorage()._speaker = nil}

  /// The type of speaker speaking this word
  public var speakerType: String {
    get {return _storage._speakerType ?? String()}
    set {_uniqueStorage()._speakerType = newValue}
  }
  /// Returns true if `speakerType` has been explicitly set.
  public var hasSpeakerType: Bool {return _storage._speakerType != nil}
  /// Clears the value of `speakerType`. Subsequent reads from it will return its default value.
  public mutating func clearSpeakerType() {_uniqueStorage()._speakerType = nil}

  /// The begin index of, e.g., a span
  public var beginIndex: UInt32 {
    get {return _storage._beginIndex ?? 0}
    set {_uniqueStorage()._beginIndex = newValue}
  }
  /// Returns true if `beginIndex` has been explicitly set.
  public var hasBeginIndex: Bool {return _storage._beginIndex != nil}
  /// Clears the value of `beginIndex`. Subsequent reads from it will return its default value.
  public mutating func clearBeginIndex() {_uniqueStorage()._beginIndex = nil}

  /// The begin index of, e.g., a span
  public var endIndex: UInt32 {
    get {return _storage._endIndex ?? 0}
    set {_uniqueStorage()._endIndex = newValue}
  }
  /// Returns true if `endIndex` has been explicitly set.
  public var hasEndIndex: Bool {return _storage._endIndex != nil}
  /// Clears the value of `endIndex`. Subsequent reads from it will return its default value.
  public mutating func clearEndIndex() {_uniqueStorage()._endIndex = nil}

  /// The begin index of the token
  public var tokenBeginIndex: UInt32 {
    get {return _storage._tokenBeginIndex ?? 0}
    set {_uniqueStorage()._tokenBeginIndex = newValue}
  }
  /// Returns true if `tokenBeginIndex` has been explicitly set.
  public var hasTokenBeginIndex: Bool {return _storage._tokenBeginIndex != nil}
  /// Clears the value of `tokenBeginIndex`. Subsequent reads from it will return its default value.
  public mutating func clearTokenBeginIndex() {_uniqueStorage()._tokenBeginIndex = nil}

  /// The end index of the token
  public var tokenEndIndex: UInt32 {
    get {return _storage._tokenEndIndex ?? 0}
    set {_uniqueStorage()._tokenEndIndex = newValue}
  }
  /// Returns true if `tokenEndIndex` has been explicitly set.
  public var hasTokenEndIndex: Bool {return _storage._tokenEndIndex != nil}
  /// Clears the value of `tokenEndIndex`. Subsequent reads from it will return its default value.
  public mutating func clearTokenEndIndex() {_uniqueStorage()._tokenEndIndex = nil}

  /// The time this word refers to
  public var timexValue: Edu_Stanford_Nlp_Pipeline_Timex {
    get {return _storage._timexValue ?? Edu_Stanford_Nlp_Pipeline_Timex()}
    set {_uniqueStorage()._timexValue = newValue}
  }
  /// Returns true if `timexValue` has been explicitly set.
  public var hasTimexValue: Bool {return _storage._timexValue != nil}
  /// Clears the value of `timexValue`. Subsequent reads from it will return its default value.
  public mutating func clearTimexValue() {_uniqueStorage()._timexValue = nil}

  /// Used by clean xml annotator
  public var hasXmlContext_p: Bool {
    get {return _storage._hasXmlContext_p ?? false}
    set {_uniqueStorage()._hasXmlContext_p = newValue}
  }
  /// Returns true if `hasXmlContext_p` has been explicitly set.
  public var hasHasXmlContext_p: Bool {return _storage._hasXmlContext_p != nil}
  /// Clears the value of `hasXmlContext_p`. Subsequent reads from it will return its default value.
  public mutating func clearHasXmlContext_p() {_uniqueStorage()._hasXmlContext_p = nil}

  /// Used by clean xml annotator
  public var xmlContext: [String] {
    get {return _storage._xmlContext}
    set {_uniqueStorage()._xmlContext = newValue}
  }

  /// The [primary] cluster id for this token
  public var corefClusterID: UInt32 {
    get {return _storage._corefClusterID ?? 0}
    set {_uniqueStorage()._corefClusterID = newValue}
  }
  /// Returns true if `corefClusterID` has been explicitly set.
  public var hasCorefClusterID: Bool {return _storage._corefClusterID != nil}
  /// Clears the value of `corefClusterID`. Subsequent reads from it will return its default value.
  public mutating func clearCorefClusterID() {_uniqueStorage()._corefClusterID = nil}

  /// A temporary annotation which is occasionally left in
  public var answer: String {
    get {return _storage._answer ?? String()}
    set {_uniqueStorage()._answer = newValue}
  }
  /// Returns true if `answer` has been explicitly set.
  public var hasAnswer: Bool {return _storage._answer != nil}
  /// Clears the value of `answer`. Subsequent reads from it will return its default value.
  public mutating func clearAnswer() {_uniqueStorage()._answer = nil}

  ///  optional string projectedCategory = 25;   // The syntactic category of the maximal constituent headed by the word. Not used anywhere, so deleted.
  public var headWordIndex: UInt32 {
    get {return _storage._headWordIndex ?? 0}
    set {_uniqueStorage()._headWordIndex = newValue}
  }
  /// Returns true if `headWordIndex` has been explicitly set.
  public var hasHeadWordIndex: Bool {return _storage._headWordIndex != nil}
  /// Clears the value of `headWordIndex`. Subsequent reads from it will return its default value.
  public mutating func clearHeadWordIndex() {_uniqueStorage()._headWordIndex = nil}

  /// If this is an operator, which one is it and what is its scope (as per Natural Logic)?
  public var `operator`: Edu_Stanford_Nlp_Pipeline_Operator {
    get {return _storage._operator ?? Edu_Stanford_Nlp_Pipeline_Operator()}
    set {_uniqueStorage()._operator = newValue}
  }
  /// Returns true if ``operator`` has been explicitly set.
  public var hasOperator: Bool {return _storage._operator != nil}
  /// Clears the value of ``operator``. Subsequent reads from it will return its default value.
  public mutating func clearOperator() {_uniqueStorage()._operator = nil}

  /// The polarity of this word, according to Natural Logic
  public var polarity: Edu_Stanford_Nlp_Pipeline_Polarity {
    get {return _storage._polarity ?? Edu_Stanford_Nlp_Pipeline_Polarity()}
    set {_uniqueStorage()._polarity = newValue}
  }
  /// Returns true if `polarity` has been explicitly set.
  public var hasPolarity: Bool {return _storage._polarity != nil}
  /// Clears the value of `polarity`. Subsequent reads from it will return its default value.
  public mutating func clearPolarity() {_uniqueStorage()._polarity = nil}

  /// The polarity of this word, either "up", "down", or "flat"
  public var polarityDir: String {
    get {return _storage._polarityDir ?? String()}
    set {_uniqueStorage()._polarityDir = newValue}
  }
  /// Returns true if `polarityDir` has been explicitly set.
  public var hasPolarityDir: Bool {return _storage._polarityDir != nil}
  /// Clears the value of `polarityDir`. Subsequent reads from it will return its default value.
  public mutating func clearPolarityDir() {_uniqueStorage()._polarityDir = nil}

  /// The span of a leaf node of a tree
  public var span: Edu_Stanford_Nlp_Pipeline_Span {
    get {return _storage._span ?? Edu_Stanford_Nlp_Pipeline_Span()}
    set {_uniqueStorage()._span = newValue}
  }
  /// Returns true if `span` has been explicitly set.
  public var hasSpan: Bool {return _storage._span != nil}
  /// Clears the value of `span`. Subsequent reads from it will return its default value.
  public mutating func clearSpan() {_uniqueStorage()._span = nil}

  /// The final sentiment of the sentence
  public var sentiment: String {
    get {return _storage._sentiment ?? String()}
    set {_uniqueStorage()._sentiment = newValue}
  }
  /// Returns true if `sentiment` has been explicitly set.
  public var hasSentiment: Bool {return _storage._sentiment != nil}
  /// Clears the value of `sentiment`. Subsequent reads from it will return its default value.
  public mutating func clearSentiment() {_uniqueStorage()._sentiment = nil}

  /// The index of the quotation this token refers to
  public var quotationIndex: Int32 {
    get {return _storage._quotationIndex ?? 0}
    set {_uniqueStorage()._quotationIndex = newValue}
  }
  /// Returns true if `quotationIndex` has been explicitly set.
  public var hasQuotationIndex: Bool {return _storage._quotationIndex != nil}
  /// Clears the value of `quotationIndex`. Subsequent reads from it will return its default value.
  public mutating func clearQuotationIndex() {_uniqueStorage()._quotationIndex = nil}

  public var conllUfeatures: Edu_Stanford_Nlp_Pipeline_MapStringString {
    get {return _storage._conllUfeatures ?? Edu_Stanford_Nlp_Pipeline_MapStringString()}
    set {_uniqueStorage()._conllUfeatures = newValue}
  }
  /// Returns true if `conllUfeatures` has been explicitly set.
  public var hasConllUfeatures: Bool {return _storage._conllUfeatures != nil}
  /// Clears the value of `conllUfeatures`. Subsequent reads from it will return its default value.
  public mutating func clearConllUfeatures() {_uniqueStorage()._conllUfeatures = nil}

  ///  The coarse POS tag (used to store the UPOS tag)
  public var coarseTag: String {
    get {return _storage._coarseTag ?? String()}
    set {_uniqueStorage()._coarseTag = newValue}
  }
  /// Returns true if `coarseTag` has been explicitly set.
  public var hasCoarseTag: Bool {return _storage._coarseTag != nil}
  /// Clears the value of `coarseTag`. Subsequent reads from it will return its default value.
  public mutating func clearCoarseTag() {_uniqueStorage()._coarseTag = nil}

  public var conllUtokenSpan: Edu_Stanford_Nlp_Pipeline_Span {
    get {return _storage._conllUtokenSpan ?? Edu_Stanford_Nlp_Pipeline_Span()}
    set {_uniqueStorage()._conllUtokenSpan = newValue}
  }
  /// Returns true if `conllUtokenSpan` has been explicitly set.
  public var hasConllUtokenSpan: Bool {return _storage._conllUtokenSpan != nil}
  /// Clears the value of `conllUtokenSpan`. Subsequent reads from it will return its default value.
  public mutating func clearConllUtokenSpan() {_uniqueStorage()._conllUtokenSpan = nil}

  public var conllUmisc: String {
    get {return _storage._conllUmisc ?? String()}
    set {_uniqueStorage()._conllUmisc = newValue}
  }
  /// Returns true if `conllUmisc` has been explicitly set.
  public var hasConllUmisc: Bool {return _storage._conllUmisc != nil}
  /// Clears the value of `conllUmisc`. Subsequent reads from it will return its default value.
  public mutating func clearConllUmisc() {_uniqueStorage()._conllUmisc = nil}

  public var conllUsecondaryDeps: Edu_Stanford_Nlp_Pipeline_MapStringString {
    get {return _storage._conllUsecondaryDeps ?? Edu_Stanford_Nlp_Pipeline_MapStringString()}
    set {_uniqueStorage()._conllUsecondaryDeps = newValue}
  }
  /// Returns true if `conllUsecondaryDeps` has been explicitly set.
  public var hasConllUsecondaryDeps: Bool {return _storage._conllUsecondaryDeps != nil}
  /// Clears the value of `conllUsecondaryDeps`. Subsequent reads from it will return its default value.
  public mutating func clearConllUsecondaryDeps() {_uniqueStorage()._conllUsecondaryDeps = nil}

  public var wikipediaEntity: String {
    get {return _storage._wikipediaEntity ?? String()}
    set {_uniqueStorage()._wikipediaEntity = newValue}
  }
  /// Returns true if `wikipediaEntity` has been explicitly set.
  public var hasWikipediaEntity: Bool {return _storage._wikipediaEntity != nil}
  /// Clears the value of `wikipediaEntity`. Subsequent reads from it will return its default value.
  public mutating func clearWikipediaEntity() {_uniqueStorage()._wikipediaEntity = nil}

  public var isNewline: Bool {
    get {return _storage._isNewline ?? false}
    set {_uniqueStorage()._isNewline = newValue}
  }
  /// Returns true if `isNewline` has been explicitly set.
  public var hasIsNewline: Bool {return _storage._isNewline != nil}
  /// Clears the value of `isNewline`. Subsequent reads from it will return its default value.
  public mutating func clearIsNewline() {_uniqueStorage()._isNewline = nil}

  /// Fields set by other annotators in CoreNLP
  public var gender: String {
    get {return _storage._gender ?? String()}
    set {_uniqueStorage()._gender = newValue}
  }
  /// Returns true if `gender` has been explicitly set.
  public var hasGender: Bool {return _storage._gender != nil}
  /// Clears the value of `gender`. Subsequent reads from it will return its default value.
  public mutating func clearGender() {_uniqueStorage()._gender = nil}

  /// true case type of token
  public var trueCase: String {
    get {return _storage._trueCase ?? String()}
    set {_uniqueStorage()._trueCase = newValue}
  }
  /// Returns true if `trueCase` has been explicitly set.
  public var hasTrueCase: Bool {return _storage._trueCase != nil}
  /// Clears the value of `trueCase`. Subsequent reads from it will return its default value.
  public mutating func clearTrueCase() {_uniqueStorage()._trueCase = nil}

  /// true case gloss of token
  public var trueCaseText: String {
    get {return _storage._trueCaseText ?? String()}
    set {_uniqueStorage()._trueCaseText = newValue}
  }
  /// Returns true if `trueCaseText` has been explicitly set.
  public var hasTrueCaseText: Bool {return _storage._trueCaseText != nil}
  /// Clears the value of `trueCaseText`. Subsequent reads from it will return its default value.
  public mutating func clearTrueCaseText() {_uniqueStorage()._trueCaseText = nil}

  ///  Chinese character info
  public var chineseChar: String {
    get {return _storage._chineseChar ?? String()}
    set {_uniqueStorage()._chineseChar = newValue}
  }
  /// Returns true if `chineseChar` has been explicitly set.
  public var hasChineseChar: Bool {return _storage._chineseChar != nil}
  /// Clears the value of `chineseChar`. Subsequent reads from it will return its default value.
  public mutating func clearChineseChar() {_uniqueStorage()._chineseChar = nil}

  public var chineseSeg: String {
    get {return _storage._chineseSeg ?? String()}
    set {_uniqueStorage()._chineseSeg = newValue}
  }
  /// Returns true if `chineseSeg` has been explicitly set.
  public var hasChineseSeg: Bool {return _storage._chineseSeg != nil}
  /// Clears the value of `chineseSeg`. Subsequent reads from it will return its default value.
  public mutating func clearChineseSeg() {_uniqueStorage()._chineseSeg = nil}

  public var chineseXmlchar: String {
    get {return _storage._chineseXmlchar ?? String()}
    set {_uniqueStorage()._chineseXmlchar = newValue}
  }
  /// Returns true if `chineseXmlchar` has been explicitly set.
  public var hasChineseXmlchar: Bool {return _storage._chineseXmlchar != nil}
  /// Clears the value of `chineseXmlchar`. Subsequent reads from it will return its default value.
  public mutating func clearChineseXmlchar() {_uniqueStorage()._chineseXmlchar = nil}

  ///  Arabic character info
  public var arabicSeg: String {
    get {return _storage._arabicSeg ?? String()}
    set {_uniqueStorage()._arabicSeg = newValue}
  }
  /// Returns true if `arabicSeg` has been explicitly set.
  public var hasArabicSeg: Bool {return _storage._arabicSeg != nil}
  /// Clears the value of `arabicSeg`. Subsequent reads from it will return its default value.
  public mutating func clearArabicSeg() {_uniqueStorage()._arabicSeg = nil}

  /// Section info
  public var sectionName: String {
    get {return _storage._sectionName ?? String()}
    set {_uniqueStorage()._sectionName = newValue}
  }
  /// Returns true if `sectionName` has been explicitly set.
  public var hasSectionName: Bool {return _storage._sectionName != nil}
  /// Clears the value of `sectionName`. Subsequent reads from it will return its default value.
  public mutating func clearSectionName() {_uniqueStorage()._sectionName = nil}

  public var sectionAuthor: String {
    get {return _storage._sectionAuthor ?? String()}
    set {_uniqueStorage()._sectionAuthor = newValue}
  }
  /// Returns true if `sectionAuthor` has been explicitly set.
  public var hasSectionAuthor: Bool {return _storage._sectionAuthor != nil}
  /// Clears the value of `sectionAuthor`. Subsequent reads from it will return its default value.
  public mutating func clearSectionAuthor() {_uniqueStorage()._sectionAuthor = nil}

  public var sectionDate: String {
    get {return _storage._sectionDate ?? String()}
    set {_uniqueStorage()._sectionDate = newValue}
  }
  /// Returns true if `sectionDate` has been explicitly set.
  public var hasSectionDate: Bool {return _storage._sectionDate != nil}
  /// Clears the value of `sectionDate`. Subsequent reads from it will return its default value.
  public mutating func clearSectionDate() {_uniqueStorage()._sectionDate = nil}

  public var sectionEndLabel: String {
    get {return _storage._sectionEndLabel ?? String()}
    set {_uniqueStorage()._sectionEndLabel = newValue}
  }
  /// Returns true if `sectionEndLabel` has been explicitly set.
  public var hasSectionEndLabel: Bool {return _storage._sectionEndLabel != nil}
  /// Clears the value of `sectionEndLabel`. Subsequent reads from it will return its default value.
  public mutating func clearSectionEndLabel() {_uniqueStorage()._sectionEndLabel = nil}

  /// French tokens have parents
  public var parent: String {
    get {return _storage._parent ?? String()}
    set {_uniqueStorage()._parent = newValue}
  }
  /// Returns true if `parent` has been explicitly set.
  public var hasParent: Bool {return _storage._parent != nil}
  /// Clears the value of `parent`. Subsequent reads from it will return its default value.
  public mutating func clearParent() {_uniqueStorage()._parent = nil}

  /// mention index info
  public var corefMentionIndex: [UInt32] {
    get {return _storage._corefMentionIndex}
    set {_uniqueStorage()._corefMentionIndex = newValue}
  }

  public var entityMentionIndex: UInt32 {
    get {return _storage._entityMentionIndex ?? 0}
    set {_uniqueStorage()._entityMentionIndex = newValue}
  }
  /// Returns true if `entityMentionIndex` has been explicitly set.
  public var hasEntityMentionIndex: Bool {return _storage._entityMentionIndex != nil}
  /// Clears the value of `entityMentionIndex`. Subsequent reads from it will return its default value.
  public mutating func clearEntityMentionIndex() {_uniqueStorage()._entityMentionIndex = nil}

  /// mwt stuff
  public var isMwt: Bool {
    get {return _storage._isMwt ?? false}
    set {_uniqueStorage()._isMwt = newValue}
  }
  /// Returns true if `isMwt` has been explicitly set.
  public var hasIsMwt: Bool {return _storage._isMwt != nil}
  /// Clears the value of `isMwt`. Subsequent reads from it will return its default value.
  public mutating func clearIsMwt() {_uniqueStorage()._isMwt = nil}

  public var isFirstMwt: Bool {
    get {return _storage._isFirstMwt ?? false}
    set {_uniqueStorage()._isFirstMwt = newValue}
  }
  /// Returns true if `isFirstMwt` has been explicitly set.
  public var hasIsFirstMwt: Bool {return _storage._isFirstMwt != nil}
  /// Clears the value of `isFirstMwt`. Subsequent reads from it will return its default value.
  public mutating func clearIsFirstMwt() {_uniqueStorage()._isFirstMwt = nil}

  public var mwtText: String {
    get {return _storage._mwtText ?? String()}
    set {_uniqueStorage()._mwtText = newValue}
  }
  /// Returns true if `mwtText` has been explicitly set.
  public var hasMwtText: Bool {return _storage._mwtText != nil}
  /// Clears the value of `mwtText`. Subsequent reads from it will return its default value.
  public mutating func clearMwtText() {_uniqueStorage()._mwtText = nil}

  /// number info
  public var numericValue: UInt64 {
    get {return _storage._numericValue ?? 0}
    set {_uniqueStorage()._numericValue = newValue}
  }
  /// Returns true if `numericValue` has been explicitly set.
  public var hasNumericValue: Bool {return _storage._numericValue != nil}
  /// Clears the value of `numericValue`. Subsequent reads from it will return its default value.
  public mutating func clearNumericValue() {_uniqueStorage()._numericValue = nil}

  public var numericType: String {
    get {return _storage._numericType ?? String()}
    set {_uniqueStorage()._numericType = newValue}
  }
  /// Returns true if `numericType` has been explicitly set.
  public var hasNumericType: Bool {return _storage._numericType != nil}
  /// Clears the value of `numericType`. Subsequent reads from it will return its default value.
  public mutating func clearNumericType() {_uniqueStorage()._numericType = nil}

  public var numericCompositeValue: UInt64 {
    get {return _storage._numericCompositeValue ?? 0}
    set {_uniqueStorage()._numericCompositeValue = newValue}
  }
  /// Returns true if `numericCompositeValue` has been explicitly set.
  public var hasNumericCompositeValue: Bool {return _storage._numericCompositeValue != nil}
  /// Clears the value of `numericCompositeValue`. Subsequent reads from it will return its default value.
  public mutating func clearNumericCompositeValue() {_uniqueStorage()._numericCompositeValue = nil}

  public var numericCompositeType: String {
    get {return _storage._numericCompositeType ?? String()}
    set {_uniqueStorage()._numericCompositeType = newValue}
  }
  /// Returns true if `numericCompositeType` has been explicitly set.
  public var hasNumericCompositeType: Bool {return _storage._numericCompositeType != nil}
  /// Clears the value of `numericCompositeType`. Subsequent reads from it will return its default value.
  public mutating func clearNumericCompositeType() {_uniqueStorage()._numericCompositeType = nil}

  public var codepointOffsetBegin: UInt32 {
    get {return _storage._codepointOffsetBegin ?? 0}
    set {_uniqueStorage()._codepointOffsetBegin = newValue}
  }
  /// Returns true if `codepointOffsetBegin` has been explicitly set.
  public var hasCodepointOffsetBegin: Bool {return _storage._codepointOffsetBegin != nil}
  /// Clears the value of `codepointOffsetBegin`. Subsequent reads from it will return its default value.
  public mutating func clearCodepointOffsetBegin() {_uniqueStorage()._codepointOffsetBegin = nil}

  public var codepointOffsetEnd: UInt32 {
    get {return _storage._codepointOffsetEnd ?? 0}
    set {_uniqueStorage()._codepointOffsetEnd = newValue}
  }
  /// Returns true if `codepointOffsetEnd` has been explicitly set.
  public var hasCodepointOffsetEnd: Bool {return _storage._codepointOffsetEnd != nil}
  /// Clears the value of `codepointOffsetEnd`. Subsequent reads from it will return its default value.
  public mutating func clearCodepointOffsetEnd() {_uniqueStorage()._codepointOffsetEnd = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  public var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _storage = _StorageClass.defaultInstance
}

///
/// A quotation marker in text
public struct Edu_Stanford_Nlp_Pipeline_Quote {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var text: String {
    get {return _storage._text ?? String()}
    set {_uniqueStorage()._text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  public var hasText: Bool {return _storage._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  public mutating func clearText() {_uniqueStorage()._text = nil}

  public var begin: UInt32 {
    get {return _storage._begin ?? 0}
    set {_uniqueStorage()._begin = newValue}
  }
  /// Returns true if `begin` has been explicitly set.
  public var hasBegin: Bool {return _storage._begin != nil}
  /// Clears the value of `begin`. Subsequent reads from it will return its default value.
  public mutating func clearBegin() {_uniqueStorage()._begin = nil}

  public var end: UInt32 {
    get {return _storage._end ?? 0}
    set {_uniqueStorage()._end = newValue}
  }
  /// Returns true if `end` has been explicitly set.
  public var hasEnd: Bool {return _storage._end != nil}
  /// Clears the value of `end`. Subsequent reads from it will return its default value.
  public mutating func clearEnd() {_uniqueStorage()._end = nil}

  public var sentenceBegin: UInt32 {
    get {return _storage._sentenceBegin ?? 0}
    set {_uniqueStorage()._sentenceBegin = newValue}
  }
  /// Returns true if `sentenceBegin` has been explicitly set.
  public var hasSentenceBegin: Bool {return _storage._sentenceBegin != nil}
  /// Clears the value of `sentenceBegin`. Subsequent reads from it will return its default value.
  public mutating func clearSentenceBegin() {_uniqueStorage()._sentenceBegin = nil}

  public var sentenceEnd: UInt32 {
    get {return _storage._sentenceEnd ?? 0}
    set {_uniqueStorage()._sentenceEnd = newValue}
  }
  /// Returns true if `sentenceEnd` has been explicitly set.
  public var hasSentenceEnd: Bool {return _storage._sentenceEnd != nil}
  /// Clears the value of `sentenceEnd`. Subsequent reads from it will return its default value.
  public mutating func clearSentenceEnd() {_uniqueStorage()._sentenceEnd = nil}

  public var tokenBegin: UInt32 {
    get {return _storage._tokenBegin ?? 0}
    set {_uniqueStorage()._tokenBegin = newValue}
  }
  /// Returns true if `tokenBegin` has been explicitly set.
  public var hasTokenBegin: Bool {return _storage._tokenBegin != nil}
  /// Clears the value of `tokenBegin`. Subsequent reads from it will return its default value.
  public mutating func clearTokenBegin() {_uniqueStorage()._tokenBegin = nil}

  public var tokenEnd: UInt32 {
    get {return _storage._tokenEnd ?? 0}
    set {_uniqueStorage()._tokenEnd = newValue}
  }
  /// Returns true if `tokenEnd` has been explicitly set.
  public var hasTokenEnd: Bool {return _storage._tokenEnd != nil}
  /// Clears the value of `tokenEnd`. Subsequent reads from it will return its default value.
  public mutating func clearTokenEnd() {_uniqueStorage()._tokenEnd = nil}

  public var docid: String {
    get {return _storage._docid ?? String()}
    set {_uniqueStorage()._docid = newValue}
  }
  /// Returns true if `docid` has been explicitly set.
  public var hasDocid: Bool {return _storage._docid != nil}
  /// Clears the value of `docid`. Subsequent reads from it will return its default value.
  public mutating func clearDocid() {_uniqueStorage()._docid = nil}

  public var index: UInt32 {
    get {return _storage._index ?? 0}
    set {_uniqueStorage()._index = newValue}
  }
  /// Returns true if `index` has been explicitly set.
  public var hasIndex: Bool {return _storage._index != nil}
  /// Clears the value of `index`. Subsequent reads from it will return its default value.
  public mutating func clearIndex() {_uniqueStorage()._index = nil}

  public var author: String {
    get {return _storage._author ?? String()}
    set {_uniqueStorage()._author = newValue}
  }
  /// Returns true if `author` has been explicitly set.
  public var hasAuthor: Bool {return _storage._author != nil}
  /// Clears the value of `author`. Subsequent reads from it will return its default value.
  public mutating func clearAuthor() {_uniqueStorage()._author = nil}

  public var mention: String {
    get {return _storage._mention ?? String()}
    set {_uniqueStorage()._mention = newValue}
  }
  /// Returns true if `mention` has been explicitly set.
  public var hasMention: Bool {return _storage._mention != nil}
  /// Clears the value of `mention`. Subsequent reads from it will return its default value.
  public mutating func clearMention() {_uniqueStorage()._mention = nil}

  public var mentionBegin: UInt32 {
    get {return _storage._mentionBegin ?? 0}
    set {_uniqueStorage()._mentionBegin = newValue}
  }
  /// Returns true if `mentionBegin` has been explicitly set.
  public var hasMentionBegin: Bool {return _storage._mentionBegin != nil}
  /// Clears the value of `mentionBegin`. Subsequent reads from it will return its default value.
  public mutating func clearMentionBegin() {_uniqueStorage()._mentionBegin = nil}

  public var mentionEnd: UInt32 {
    get {return _storage._mentionEnd ?? 0}
    set {_uniqueStorage()._mentionEnd = newValue}
  }
  /// Returns true if `mentionEnd` has been explicitly set.
  public var hasMentionEnd: Bool {return _storage._mentionEnd != nil}
  /// Clears the value of `mentionEnd`. Subsequent reads from it will return its default value.
  public mutating func clearMentionEnd() {_uniqueStorage()._mentionEnd = nil}

  public var mentionType: String {
    get {return _storage._mentionType ?? String()}
    set {_uniqueStorage()._mentionType = newValue}
  }
  /// Returns true if `mentionType` has been explicitly set.
  public var hasMentionType: Bool {return _storage._mentionType != nil}
  /// Clears the value of `mentionType`. Subsequent reads from it will return its default value.
  public mutating func clearMentionType() {_uniqueStorage()._mentionType = nil}

  public var mentionSieve: String {
    get {return _storage._mentionSieve ?? String()}
    set {_uniqueStorage()._mentionSieve = newValue}
  }
  /// Returns true if `mentionSieve` has been explicitly set.
  public var hasMentionSieve: Bool {return _storage._mentionSieve != nil}
  /// Clears the value of `mentionSieve`. Subsequent reads from it will return its default value.
  public mutating func clearMentionSieve() {_uniqueStorage()._mentionSieve = nil}

  public var speaker: String {
    get {return _storage._speaker ?? String()}
    set {_uniqueStorage()._speaker = newValue}
  }
  /// Returns true if `speaker` has been explicitly set.
  public var hasSpeaker: Bool {return _storage._speaker != nil}
  /// Clears the value of `speaker`. Subsequent reads from it will return its default value.
  public mutating func clearSpeaker() {_uniqueStorage()._speaker = nil}

  public var speakerSieve: String {
    get {return _storage._speakerSieve ?? String()}
    set {_uniqueStorage()._speakerSieve = newValue}
  }
  /// Returns true if `speakerSieve` has been explicitly set.
  public var hasSpeakerSieve: Bool {return _storage._speakerSieve != nil}
  /// Clears the value of `speakerSieve`. Subsequent reads from it will return its default value.
  public mutating func clearSpeakerSieve() {_uniqueStorage()._speakerSieve = nil}

  public var canonicalMention: String {
    get {return _storage._canonicalMention ?? String()}
    set {_uniqueStorage()._canonicalMention = newValue}
  }
  /// Returns true if `canonicalMention` has been explicitly set.
  public var hasCanonicalMention: Bool {return _storage._canonicalMention != nil}
  /// Clears the value of `canonicalMention`. Subsequent reads from it will return its default value.
  public mutating func clearCanonicalMention() {_uniqueStorage()._canonicalMention = nil}

  public var canonicalMentionBegin: UInt32 {
    get {return _storage._canonicalMentionBegin ?? 0}
    set {_uniqueStorage()._canonicalMentionBegin = newValue}
  }
  /// Returns true if `canonicalMentionBegin` has been explicitly set.
  public var hasCanonicalMentionBegin: Bool {return _storage._canonicalMentionBegin != nil}
  /// Clears the value of `canonicalMentionBegin`. Subsequent reads from it will return its default value.
  public mutating func clearCanonicalMentionBegin() {_uniqueStorage()._canonicalMentionBegin = nil}

  public var canonicalMentionEnd: UInt32 {
    get {return _storage._canonicalMentionEnd ?? 0}
    set {_uniqueStorage()._canonicalMentionEnd = newValue}
  }
  /// Returns true if `canonicalMentionEnd` has been explicitly set.
  public var hasCanonicalMentionEnd: Bool {return _storage._canonicalMentionEnd != nil}
  /// Clears the value of `canonicalMentionEnd`. Subsequent reads from it will return its default value.
  public mutating func clearCanonicalMentionEnd() {_uniqueStorage()._canonicalMentionEnd = nil}

  public var attributionDependencyGraph: Edu_Stanford_Nlp_Pipeline_DependencyGraph {
    get {return _storage._attributionDependencyGraph ?? Edu_Stanford_Nlp_Pipeline_DependencyGraph()}
    set {_uniqueStorage()._attributionDependencyGraph = newValue}
  }
  /// Returns true if `attributionDependencyGraph` has been explicitly set.
  public var hasAttributionDependencyGraph: Bool {return _storage._attributionDependencyGraph != nil}
  /// Clears the value of `attributionDependencyGraph`. Subsequent reads from it will return its default value.
  public mutating func clearAttributionDependencyGraph() {_uniqueStorage()._attributionDependencyGraph = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///
/// A syntactic parse tree, with scores.
public struct Edu_Stanford_Nlp_Pipeline_ParseTree {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var child: [Edu_Stanford_Nlp_Pipeline_ParseTree] = []

  public var value: String {
    get {return _value ?? String()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var yieldBeginIndex: UInt32 {
    get {return _yieldBeginIndex ?? 0}
    set {_yieldBeginIndex = newValue}
  }
  /// Returns true if `yieldBeginIndex` has been explicitly set.
  public var hasYieldBeginIndex: Bool {return self._yieldBeginIndex != nil}
  /// Clears the value of `yieldBeginIndex`. Subsequent reads from it will return its default value.
  public mutating func clearYieldBeginIndex() {self._yieldBeginIndex = nil}

  public var yieldEndIndex: UInt32 {
    get {return _yieldEndIndex ?? 0}
    set {_yieldEndIndex = newValue}
  }
  /// Returns true if `yieldEndIndex` has been explicitly set.
  public var hasYieldEndIndex: Bool {return self._yieldEndIndex != nil}
  /// Clears the value of `yieldEndIndex`. Subsequent reads from it will return its default value.
  public mutating func clearYieldEndIndex() {self._yieldEndIndex = nil}

  public var score: Double {
    get {return _score ?? 0}
    set {_score = newValue}
  }
  /// Returns true if `score` has been explicitly set.
  public var hasScore: Bool {return self._score != nil}
  /// Clears the value of `score`. Subsequent reads from it will return its default value.
  public mutating func clearScore() {self._score = nil}

  public var sentiment: Edu_Stanford_Nlp_Pipeline_Sentiment {
    get {return _sentiment ?? .strongNegative}
    set {_sentiment = newValue}
  }
  /// Returns true if `sentiment` has been explicitly set.
  public var hasSentiment: Bool {return self._sentiment != nil}
  /// Clears the value of `sentiment`. Subsequent reads from it will return its default value.
  public mutating func clearSentiment() {self._sentiment = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _value: String? = nil
  fileprivate var _yieldBeginIndex: UInt32? = nil
  fileprivate var _yieldEndIndex: UInt32? = nil
  fileprivate var _score: Double? = nil
  fileprivate var _sentiment: Edu_Stanford_Nlp_Pipeline_Sentiment? = nil
}

///
/// A dependency graph representation.
public struct Edu_Stanford_Nlp_Pipeline_DependencyGraph {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var node: [Edu_Stanford_Nlp_Pipeline_DependencyGraph.Node] = []

  public var edge: [Edu_Stanford_Nlp_Pipeline_DependencyGraph.Edge] = []

  public var root: [UInt32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Node {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var sentenceIndex: UInt32 {
      get {return _sentenceIndex ?? 0}
      set {_sentenceIndex = newValue}
    }
    /// Returns true if `sentenceIndex` has been explicitly set.
    public var hasSentenceIndex: Bool {return self._sentenceIndex != nil}
    /// Clears the value of `sentenceIndex`. Subsequent reads from it will return its default value.
    public mutating func clearSentenceIndex() {self._sentenceIndex = nil}

    public var index: UInt32 {
      get {return _index ?? 0}
      set {_index = newValue}
    }
    /// Returns true if `index` has been explicitly set.
    public var hasIndex: Bool {return self._index != nil}
    /// Clears the value of `index`. Subsequent reads from it will return its default value.
    public mutating func clearIndex() {self._index = nil}

    public var copyAnnotation: UInt32 {
      get {return _copyAnnotation ?? 0}
      set {_copyAnnotation = newValue}
    }
    /// Returns true if `copyAnnotation` has been explicitly set.
    public var hasCopyAnnotation: Bool {return self._copyAnnotation != nil}
    /// Clears the value of `copyAnnotation`. Subsequent reads from it will return its default value.
    public mutating func clearCopyAnnotation() {self._copyAnnotation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _sentenceIndex: UInt32? = nil
    fileprivate var _index: UInt32? = nil
    fileprivate var _copyAnnotation: UInt32? = nil
  }

  public struct Edge {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var source: UInt32 {
      get {return _source ?? 0}
      set {_source = newValue}
    }
    /// Returns true if `source` has been explicitly set.
    public var hasSource: Bool {return self._source != nil}
    /// Clears the value of `source`. Subsequent reads from it will return its default value.
    public mutating func clearSource() {self._source = nil}

    public var target: UInt32 {
      get {return _target ?? 0}
      set {_target = newValue}
    }
    /// Returns true if `target` has been explicitly set.
    public var hasTarget: Bool {return self._target != nil}
    /// Clears the value of `target`. Subsequent reads from it will return its default value.
    public mutating func clearTarget() {self._target = nil}

    public var dep: String {
      get {return _dep ?? String()}
      set {_dep = newValue}
    }
    /// Returns true if `dep` has been explicitly set.
    public var hasDep: Bool {return self._dep != nil}
    /// Clears the value of `dep`. Subsequent reads from it will return its default value.
    public mutating func clearDep() {self._dep = nil}

    public var isExtra: Bool {
      get {return _isExtra ?? false}
      set {_isExtra = newValue}
    }
    /// Returns true if `isExtra` has been explicitly set.
    public var hasIsExtra: Bool {return self._isExtra != nil}
    /// Clears the value of `isExtra`. Subsequent reads from it will return its default value.
    public mutating func clearIsExtra() {self._isExtra = nil}

    public var sourceCopy: UInt32 {
      get {return _sourceCopy ?? 0}
      set {_sourceCopy = newValue}
    }
    /// Returns true if `sourceCopy` has been explicitly set.
    public var hasSourceCopy: Bool {return self._sourceCopy != nil}
    /// Clears the value of `sourceCopy`. Subsequent reads from it will return its default value.
    public mutating func clearSourceCopy() {self._sourceCopy = nil}

    public var targetCopy: UInt32 {
      get {return _targetCopy ?? 0}
      set {_targetCopy = newValue}
    }
    /// Returns true if `targetCopy` has been explicitly set.
    public var hasTargetCopy: Bool {return self._targetCopy != nil}
    /// Clears the value of `targetCopy`. Subsequent reads from it will return its default value.
    public mutating func clearTargetCopy() {self._targetCopy = nil}

    public var language: Edu_Stanford_Nlp_Pipeline_Language {
      get {return _language ?? .unknown}
      set {_language = newValue}
    }
    /// Returns true if `language` has been explicitly set.
    public var hasLanguage: Bool {return self._language != nil}
    /// Clears the value of `language`. Subsequent reads from it will return its default value.
    public mutating func clearLanguage() {self._language = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _source: UInt32? = nil
    fileprivate var _target: UInt32? = nil
    fileprivate var _dep: String? = nil
    fileprivate var _isExtra: Bool? = nil
    fileprivate var _sourceCopy: UInt32? = nil
    fileprivate var _targetCopy: UInt32? = nil
    fileprivate var _language: Edu_Stanford_Nlp_Pipeline_Language? = nil
  }

  public init() {}
}

///
/// A coreference chain.
/// These fields are not *really* optional. CoreNLP will crash without them.
public struct Edu_Stanford_Nlp_Pipeline_CorefChain {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chainID: Int32 {
    get {return _chainID ?? 0}
    set {_chainID = newValue}
  }
  /// Returns true if `chainID` has been explicitly set.
  public var hasChainID: Bool {return self._chainID != nil}
  /// Clears the value of `chainID`. Subsequent reads from it will return its default value.
  public mutating func clearChainID() {self._chainID = nil}

  public var mention: [Edu_Stanford_Nlp_Pipeline_CorefChain.CorefMention] = []

  public var representative: UInt32 {
    get {return _representative ?? 0}
    set {_representative = newValue}
  }
  /// Returns true if `representative` has been explicitly set.
  public var hasRepresentative: Bool {return self._representative != nil}
  /// Clears the value of `representative`. Subsequent reads from it will return its default value.
  public mutating func clearRepresentative() {self._representative = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct CorefMention {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var mentionID: Int32 {
      get {return _mentionID ?? 0}
      set {_mentionID = newValue}
    }
    /// Returns true if `mentionID` has been explicitly set.
    public var hasMentionID: Bool {return self._mentionID != nil}
    /// Clears the value of `mentionID`. Subsequent reads from it will return its default value.
    public mutating func clearMentionID() {self._mentionID = nil}

    public var mentionType: String {
      get {return _mentionType ?? String()}
      set {_mentionType = newValue}
    }
    /// Returns true if `mentionType` has been explicitly set.
    public var hasMentionType: Bool {return self._mentionType != nil}
    /// Clears the value of `mentionType`. Subsequent reads from it will return its default value.
    public mutating func clearMentionType() {self._mentionType = nil}

    public var number: String {
      get {return _number ?? String()}
      set {_number = newValue}
    }
    /// Returns true if `number` has been explicitly set.
    public var hasNumber: Bool {return self._number != nil}
    /// Clears the value of `number`. Subsequent reads from it will return its default value.
    public mutating func clearNumber() {self._number = nil}

    public var gender: String {
      get {return _gender ?? String()}
      set {_gender = newValue}
    }
    /// Returns true if `gender` has been explicitly set.
    public var hasGender: Bool {return self._gender != nil}
    /// Clears the value of `gender`. Subsequent reads from it will return its default value.
    public mutating func clearGender() {self._gender = nil}

    public var animacy: String {
      get {return _animacy ?? String()}
      set {_animacy = newValue}
    }
    /// Returns true if `animacy` has been explicitly set.
    public var hasAnimacy: Bool {return self._animacy != nil}
    /// Clears the value of `animacy`. Subsequent reads from it will return its default value.
    public mutating func clearAnimacy() {self._animacy = nil}

    public var beginIndex: UInt32 {
      get {return _beginIndex ?? 0}
      set {_beginIndex = newValue}
    }
    /// Returns true if `beginIndex` has been explicitly set.
    public var hasBeginIndex: Bool {return self._beginIndex != nil}
    /// Clears the value of `beginIndex`. Subsequent reads from it will return its default value.
    public mutating func clearBeginIndex() {self._beginIndex = nil}

    public var endIndex: UInt32 {
      get {return _endIndex ?? 0}
      set {_endIndex = newValue}
    }
    /// Returns true if `endIndex` has been explicitly set.
    public var hasEndIndex: Bool {return self._endIndex != nil}
    /// Clears the value of `endIndex`. Subsequent reads from it will return its default value.
    public mutating func clearEndIndex() {self._endIndex = nil}

    public var headIndex: UInt32 {
      get {return _headIndex ?? 0}
      set {_headIndex = newValue}
    }
    /// Returns true if `headIndex` has been explicitly set.
    public var hasHeadIndex: Bool {return self._headIndex != nil}
    /// Clears the value of `headIndex`. Subsequent reads from it will return its default value.
    public mutating func clearHeadIndex() {self._headIndex = nil}

    public var sentenceIndex: UInt32 {
      get {return _sentenceIndex ?? 0}
      set {_sentenceIndex = newValue}
    }
    /// Returns true if `sentenceIndex` has been explicitly set.
    public var hasSentenceIndex: Bool {return self._sentenceIndex != nil}
    /// Clears the value of `sentenceIndex`. Subsequent reads from it will return its default value.
    public mutating func clearSentenceIndex() {self._sentenceIndex = nil}

    /// the second element of position
    public var position: UInt32 {
      get {return _position ?? 0}
      set {_position = newValue}
    }
    /// Returns true if `position` has been explicitly set.
    public var hasPosition: Bool {return self._position != nil}
    /// Clears the value of `position`. Subsequent reads from it will return its default value.
    public mutating func clearPosition() {self._position = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _mentionID: Int32? = nil
    fileprivate var _mentionType: String? = nil
    fileprivate var _number: String? = nil
    fileprivate var _gender: String? = nil
    fileprivate var _animacy: String? = nil
    fileprivate var _beginIndex: UInt32? = nil
    fileprivate var _endIndex: UInt32? = nil
    fileprivate var _headIndex: UInt32? = nil
    fileprivate var _sentenceIndex: UInt32? = nil
    fileprivate var _position: UInt32? = nil
  }

  public init() {}

  fileprivate var _chainID: Int32? = nil
  fileprivate var _representative: UInt32? = nil
}

public struct Edu_Stanford_Nlp_Pipeline_Mention {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mentionID: Int32 {
    get {return _storage._mentionID ?? 0}
    set {_uniqueStorage()._mentionID = newValue}
  }
  /// Returns true if `mentionID` has been explicitly set.
  public var hasMentionID: Bool {return _storage._mentionID != nil}
  /// Clears the value of `mentionID`. Subsequent reads from it will return its default value.
  public mutating func clearMentionID() {_uniqueStorage()._mentionID = nil}

  public var mentionType: String {
    get {return _storage._mentionType ?? String()}
    set {_uniqueStorage()._mentionType = newValue}
  }
  /// Returns true if `mentionType` has been explicitly set.
  public var hasMentionType: Bool {return _storage._mentionType != nil}
  /// Clears the value of `mentionType`. Subsequent reads from it will return its default value.
  public mutating func clearMentionType() {_uniqueStorage()._mentionType = nil}

  public var number: String {
    get {return _storage._number ?? String()}
    set {_uniqueStorage()._number = newValue}
  }
  /// Returns true if `number` has been explicitly set.
  public var hasNumber: Bool {return _storage._number != nil}
  /// Clears the value of `number`. Subsequent reads from it will return its default value.
  public mutating func clearNumber() {_uniqueStorage()._number = nil}

  public var gender: String {
    get {return _storage._gender ?? String()}
    set {_uniqueStorage()._gender = newValue}
  }
  /// Returns true if `gender` has been explicitly set.
  public var hasGender: Bool {return _storage._gender != nil}
  /// Clears the value of `gender`. Subsequent reads from it will return its default value.
  public mutating func clearGender() {_uniqueStorage()._gender = nil}

  public var animacy: String {
    get {return _storage._animacy ?? String()}
    set {_uniqueStorage()._animacy = newValue}
  }
  /// Returns true if `animacy` has been explicitly set.
  public var hasAnimacy: Bool {return _storage._animacy != nil}
  /// Clears the value of `animacy`. Subsequent reads from it will return its default value.
  public mutating func clearAnimacy() {_uniqueStorage()._animacy = nil}

  public var person: String {
    get {return _storage._person ?? String()}
    set {_uniqueStorage()._person = newValue}
  }
  /// Returns true if `person` has been explicitly set.
  public var hasPerson: Bool {return _storage._person != nil}
  /// Clears the value of `person`. Subsequent reads from it will return its default value.
  public mutating func clearPerson() {_uniqueStorage()._person = nil}

  public var startIndex: UInt32 {
    get {return _storage._startIndex ?? 0}
    set {_uniqueStorage()._startIndex = newValue}
  }
  /// Returns true if `startIndex` has been explicitly set.
  public var hasStartIndex: Bool {return _storage._startIndex != nil}
  /// Clears the value of `startIndex`. Subsequent reads from it will return its default value.
  public mutating func clearStartIndex() {_uniqueStorage()._startIndex = nil}

  public var endIndex: UInt32 {
    get {return _storage._endIndex ?? 0}
    set {_uniqueStorage()._endIndex = newValue}
  }
  /// Returns true if `endIndex` has been explicitly set.
  public var hasEndIndex: Bool {return _storage._endIndex != nil}
  /// Clears the value of `endIndex`. Subsequent reads from it will return its default value.
  public mutating func clearEndIndex() {_uniqueStorage()._endIndex = nil}

  public var headIndex: Int32 {
    get {return _storage._headIndex ?? 0}
    set {_uniqueStorage()._headIndex = newValue}
  }
  /// Returns true if `headIndex` has been explicitly set.
  public var hasHeadIndex: Bool {return _storage._headIndex != nil}
  /// Clears the value of `headIndex`. Subsequent reads from it will return its default value.
  public mutating func clearHeadIndex() {_uniqueStorage()._headIndex = nil}

  public var headString: String {
    get {return _storage._headString ?? String()}
    set {_uniqueStorage()._headString = newValue}
  }
  /// Returns true if `headString` has been explicitly set.
  public var hasHeadString: Bool {return _storage._headString != nil}
  /// Clears the value of `headString`. Subsequent reads from it will return its default value.
  public mutating func clearHeadString() {_uniqueStorage()._headString = nil}

  public var nerString: String {
    get {return _storage._nerString ?? String()}
    set {_uniqueStorage()._nerString = newValue}
  }
  /// Returns true if `nerString` has been explicitly set.
  public var hasNerString: Bool {return _storage._nerString != nil}
  /// Clears the value of `nerString`. Subsequent reads from it will return its default value.
  public mutating func clearNerString() {_uniqueStorage()._nerString = nil}

  public var originalRef: Int32 {
    get {return _storage._originalRef ?? 0}
    set {_uniqueStorage()._originalRef = newValue}
  }
  /// Returns true if `originalRef` has been explicitly set.
  public var hasOriginalRef: Bool {return _storage._originalRef != nil}
  /// Clears the value of `originalRef`. Subsequent reads from it will return its default value.
  public mutating func clearOriginalRef() {_uniqueStorage()._originalRef = nil}

  public var goldCorefClusterID: Int32 {
    get {return _storage._goldCorefClusterID ?? 0}
    set {_uniqueStorage()._goldCorefClusterID = newValue}
  }
  /// Returns true if `goldCorefClusterID` has been explicitly set.
  public var hasGoldCorefClusterID: Bool {return _storage._goldCorefClusterID != nil}
  /// Clears the value of `goldCorefClusterID`. Subsequent reads from it will return its default value.
  public mutating func clearGoldCorefClusterID() {_uniqueStorage()._goldCorefClusterID = nil}

  public var corefClusterID: Int32 {
    get {return _storage._corefClusterID ?? 0}
    set {_uniqueStorage()._corefClusterID = newValue}
  }
  /// Returns true if `corefClusterID` has been explicitly set.
  public var hasCorefClusterID: Bool {return _storage._corefClusterID != nil}
  /// Clears the value of `corefClusterID`. Subsequent reads from it will return its default value.
  public mutating func clearCorefClusterID() {_uniqueStorage()._corefClusterID = nil}

  public var mentionNum: Int32 {
    get {return _storage._mentionNum ?? 0}
    set {_uniqueStorage()._mentionNum = newValue}
  }
  /// Returns true if `mentionNum` has been explicitly set.
  public var hasMentionNum: Bool {return _storage._mentionNum != nil}
  /// Clears the value of `mentionNum`. Subsequent reads from it will return its default value.
  public mutating func clearMentionNum() {_uniqueStorage()._mentionNum = nil}

  public var sentNum: Int32 {
    get {return _storage._sentNum ?? 0}
    set {_uniqueStorage()._sentNum = newValue}
  }
  /// Returns true if `sentNum` has been explicitly set.
  public var hasSentNum: Bool {return _storage._sentNum != nil}
  /// Clears the value of `sentNum`. Subsequent reads from it will return its default value.
  public mutating func clearSentNum() {_uniqueStorage()._sentNum = nil}

  public var utter: Int32 {
    get {return _storage._utter ?? 0}
    set {_uniqueStorage()._utter = newValue}
  }
  /// Returns true if `utter` has been explicitly set.
  public var hasUtter: Bool {return _storage._utter != nil}
  /// Clears the value of `utter`. Subsequent reads from it will return its default value.
  public mutating func clearUtter() {_uniqueStorage()._utter = nil}

  public var paragraph: Int32 {
    get {return _storage._paragraph ?? 0}
    set {_uniqueStorage()._paragraph = newValue}
  }
  /// Returns true if `paragraph` has been explicitly set.
  public var hasParagraph: Bool {return _storage._paragraph != nil}
  /// Clears the value of `paragraph`. Subsequent reads from it will return its default value.
  public mutating func clearParagraph() {_uniqueStorage()._paragraph = nil}

  public var isSubject: Bool {
    get {return _storage._isSubject ?? false}
    set {_uniqueStorage()._isSubject = newValue}
  }
  /// Returns true if `isSubject` has been explicitly set.
  public var hasIsSubject: Bool {return _storage._isSubject != nil}
  /// Clears the value of `isSubject`. Subsequent reads from it will return its default value.
  public mutating func clearIsSubject() {_uniqueStorage()._isSubject = nil}

  public var isDirectObject: Bool {
    get {return _storage._isDirectObject ?? false}
    set {_uniqueStorage()._isDirectObject = newValue}
  }
  /// Returns true if `isDirectObject` has been explicitly set.
  public var hasIsDirectObject: Bool {return _storage._isDirectObject != nil}
  /// Clears the value of `isDirectObject`. Subsequent reads from it will return its default value.
  public mutating func clearIsDirectObject() {_uniqueStorage()._isDirectObject = nil}

  public var isIndirectObject: Bool {
    get {return _storage._isIndirectObject ?? false}
    set {_uniqueStorage()._isIndirectObject = newValue}
  }
  /// Returns true if `isIndirectObject` has been explicitly set.
  public var hasIsIndirectObject: Bool {return _storage._isIndirectObject != nil}
  /// Clears the value of `isIndirectObject`. Subsequent reads from it will return its default value.
  public mutating func clearIsIndirectObject() {_uniqueStorage()._isIndirectObject = nil}

  public var isPrepositionObject: Bool {
    get {return _storage._isPrepositionObject ?? false}
    set {_uniqueStorage()._isPrepositionObject = newValue}
  }
  /// Returns true if `isPrepositionObject` has been explicitly set.
  public var hasIsPrepositionObject: Bool {return _storage._isPrepositionObject != nil}
  /// Clears the value of `isPrepositionObject`. Subsequent reads from it will return its default value.
  public mutating func clearIsPrepositionObject() {_uniqueStorage()._isPrepositionObject = nil}

  public var hasTwin_p: Bool {
    get {return _storage._hasTwin_p ?? false}
    set {_uniqueStorage()._hasTwin_p = newValue}
  }
  /// Returns true if `hasTwin_p` has been explicitly set.
  public var hasHasTwin_p: Bool {return _storage._hasTwin_p != nil}
  /// Clears the value of `hasTwin_p`. Subsequent reads from it will return its default value.
  public mutating func clearHasTwin_p() {_uniqueStorage()._hasTwin_p = nil}

  public var generic: Bool {
    get {return _storage._generic ?? false}
    set {_uniqueStorage()._generic = newValue}
  }
  /// Returns true if `generic` has been explicitly set.
  public var hasGeneric: Bool {return _storage._generic != nil}
  /// Clears the value of `generic`. Subsequent reads from it will return its default value.
  public mutating func clearGeneric() {_uniqueStorage()._generic = nil}

  public var isSingleton: Bool {
    get {return _storage._isSingleton ?? false}
    set {_uniqueStorage()._isSingleton = newValue}
  }
  /// Returns true if `isSingleton` has been explicitly set.
  public var hasIsSingleton: Bool {return _storage._isSingleton != nil}
  /// Clears the value of `isSingleton`. Subsequent reads from it will return its default value.
  public mutating func clearIsSingleton() {_uniqueStorage()._isSingleton = nil}

  public var hasBasicDependency_p: Bool {
    get {return _storage._hasBasicDependency_p ?? false}
    set {_uniqueStorage()._hasBasicDependency_p = newValue}
  }
  /// Returns true if `hasBasicDependency_p` has been explicitly set.
  public var hasHasBasicDependency_p: Bool {return _storage._hasBasicDependency_p != nil}
  /// Clears the value of `hasBasicDependency_p`. Subsequent reads from it will return its default value.
  public mutating func clearHasBasicDependency_p() {_uniqueStorage()._hasBasicDependency_p = nil}

  public var hasEnhancedDepenedncy_p: Bool {
    get {return _storage._hasEnhancedDepenedncy_p ?? false}
    set {_uniqueStorage()._hasEnhancedDepenedncy_p = newValue}
  }
  /// Returns true if `hasEnhancedDepenedncy_p` has been explicitly set.
  public var hasHasEnhancedDepenedncy_p: Bool {return _storage._hasEnhancedDepenedncy_p != nil}
  /// Clears the value of `hasEnhancedDepenedncy_p`. Subsequent reads from it will return its default value.
  public mutating func clearHasEnhancedDepenedncy_p() {_uniqueStorage()._hasEnhancedDepenedncy_p = nil}

  public var hasContextParseTree_p: Bool {
    get {return _storage._hasContextParseTree_p ?? false}
    set {_uniqueStorage()._hasContextParseTree_p = newValue}
  }
  /// Returns true if `hasContextParseTree_p` has been explicitly set.
  public var hasHasContextParseTree_p: Bool {return _storage._hasContextParseTree_p != nil}
  /// Clears the value of `hasContextParseTree_p`. Subsequent reads from it will return its default value.
  public mutating func clearHasContextParseTree_p() {_uniqueStorage()._hasContextParseTree_p = nil}

  public var headIndexedWord: Edu_Stanford_Nlp_Pipeline_IndexedWord {
    get {return _storage._headIndexedWord ?? Edu_Stanford_Nlp_Pipeline_IndexedWord()}
    set {_uniqueStorage()._headIndexedWord = newValue}
  }
  /// Returns true if `headIndexedWord` has been explicitly set.
  public var hasHeadIndexedWord: Bool {return _storage._headIndexedWord != nil}
  /// Clears the value of `headIndexedWord`. Subsequent reads from it will return its default value.
  public mutating func clearHeadIndexedWord() {_uniqueStorage()._headIndexedWord = nil}

  public var dependingVerb: Edu_Stanford_Nlp_Pipeline_IndexedWord {
    get {return _storage._dependingVerb ?? Edu_Stanford_Nlp_Pipeline_IndexedWord()}
    set {_uniqueStorage()._dependingVerb = newValue}
  }
  /// Returns true if `dependingVerb` has been explicitly set.
  public var hasDependingVerb: Bool {return _storage._dependingVerb != nil}
  /// Clears the value of `dependingVerb`. Subsequent reads from it will return its default value.
  public mutating func clearDependingVerb() {_uniqueStorage()._dependingVerb = nil}

  public var headWord: Edu_Stanford_Nlp_Pipeline_IndexedWord {
    get {return _storage._headWord ?? Edu_Stanford_Nlp_Pipeline_IndexedWord()}
    set {_uniqueStorage()._headWord = newValue}
  }
  /// Returns true if `headWord` has been explicitly set.
  public var hasHeadWord: Bool {return _storage._headWord != nil}
  /// Clears the value of `headWord`. Subsequent reads from it will return its default value.
  public mutating func clearHeadWord() {_uniqueStorage()._headWord = nil}

  public var speakerInfo: Edu_Stanford_Nlp_Pipeline_SpeakerInfo {
    get {return _storage._speakerInfo ?? Edu_Stanford_Nlp_Pipeline_SpeakerInfo()}
    set {_uniqueStorage()._speakerInfo = newValue}
  }
  /// Returns true if `speakerInfo` has been explicitly set.
  public var hasSpeakerInfo: Bool {return _storage._speakerInfo != nil}
  /// Clears the value of `speakerInfo`. Subsequent reads from it will return its default value.
  public mutating func clearSpeakerInfo() {_uniqueStorage()._speakerInfo = nil}

  public var sentenceWords: [Edu_Stanford_Nlp_Pipeline_IndexedWord] {
    get {return _storage._sentenceWords}
    set {_uniqueStorage()._sentenceWords = newValue}
  }

  public var originalSpan: [Edu_Stanford_Nlp_Pipeline_IndexedWord] {
    get {return _storage._originalSpan}
    set {_uniqueStorage()._originalSpan = newValue}
  }

  public var dependents: [String] {
    get {return _storage._dependents}
    set {_uniqueStorage()._dependents = newValue}
  }

  public var preprocessedTerms: [String] {
    get {return _storage._preprocessedTerms}
    set {_uniqueStorage()._preprocessedTerms = newValue}
  }

  public var appositions: [Int32] {
    get {return _storage._appositions}
    set {_uniqueStorage()._appositions = newValue}
  }

  public var predicateNominatives: [Int32] {
    get {return _storage._predicateNominatives}
    set {_uniqueStorage()._predicateNominatives = newValue}
  }

  public var relativePronouns: [Int32] {
    get {return _storage._relativePronouns}
    set {_uniqueStorage()._relativePronouns = newValue}
  }

  public var listMembers: [Int32] {
    get {return _storage._listMembers}
    set {_uniqueStorage()._listMembers = newValue}
  }

  public var belongToLists: [Int32] {
    get {return _storage._belongToLists}
    set {_uniqueStorage()._belongToLists = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Edu_Stanford_Nlp_Pipeline_IndexedWord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sentenceNum: Int32 {
    get {return _sentenceNum ?? 0}
    set {_sentenceNum = newValue}
  }
  /// Returns true if `sentenceNum` has been explicitly set.
  public var hasSentenceNum: Bool {return self._sentenceNum != nil}
  /// Clears the value of `sentenceNum`. Subsequent reads from it will return its default value.
  public mutating func clearSentenceNum() {self._sentenceNum = nil}

  public var tokenIndex: Int32 {
    get {return _tokenIndex ?? 0}
    set {_tokenIndex = newValue}
  }
  /// Returns true if `tokenIndex` has been explicitly set.
  public var hasTokenIndex: Bool {return self._tokenIndex != nil}
  /// Clears the value of `tokenIndex`. Subsequent reads from it will return its default value.
  public mutating func clearTokenIndex() {self._tokenIndex = nil}

  public var docID: Int32 {
    get {return _docID ?? 0}
    set {_docID = newValue}
  }
  /// Returns true if `docID` has been explicitly set.
  public var hasDocID: Bool {return self._docID != nil}
  /// Clears the value of `docID`. Subsequent reads from it will return its default value.
  public mutating func clearDocID() {self._docID = nil}

  public var copyCount: UInt32 {
    get {return _copyCount ?? 0}
    set {_copyCount = newValue}
  }
  /// Returns true if `copyCount` has been explicitly set.
  public var hasCopyCount: Bool {return self._copyCount != nil}
  /// Clears the value of `copyCount`. Subsequent reads from it will return its default value.
  public mutating func clearCopyCount() {self._copyCount = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sentenceNum: Int32? = nil
  fileprivate var _tokenIndex: Int32? = nil
  fileprivate var _docID: Int32? = nil
  fileprivate var _copyCount: UInt32? = nil
}

public struct Edu_Stanford_Nlp_Pipeline_SpeakerInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var speakerName: String {
    get {return _speakerName ?? String()}
    set {_speakerName = newValue}
  }
  /// Returns true if `speakerName` has been explicitly set.
  public var hasSpeakerName: Bool {return self._speakerName != nil}
  /// Clears the value of `speakerName`. Subsequent reads from it will return its default value.
  public mutating func clearSpeakerName() {self._speakerName = nil}

  public var mentions: [Int32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _speakerName: String? = nil
}

///
/// A Span of text
public struct Edu_Stanford_Nlp_Pipeline_Span {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var begin: UInt32 {
    get {return _begin ?? 0}
    set {_begin = newValue}
  }
  /// Returns true if `begin` has been explicitly set.
  public var hasBegin: Bool {return self._begin != nil}
  /// Clears the value of `begin`. Subsequent reads from it will return its default value.
  public mutating func clearBegin() {self._begin = nil}

  public var end: UInt32 {
    get {return _end ?? 0}
    set {_end = newValue}
  }
  /// Returns true if `end` has been explicitly set.
  public var hasEnd: Bool {return self._end != nil}
  /// Clears the value of `end`. Subsequent reads from it will return its default value.
  public mutating func clearEnd() {self._end = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _begin: UInt32? = nil
  fileprivate var _end: UInt32? = nil
}

///
/// A Timex object, representing a temporal expression (TIMe EXpression)
/// These fields are not *really* optional. CoreNLP will crash without them.
public struct Edu_Stanford_Nlp_Pipeline_Timex {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: String {
    get {return _value ?? String()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var altValue: String {
    get {return _altValue ?? String()}
    set {_altValue = newValue}
  }
  /// Returns true if `altValue` has been explicitly set.
  public var hasAltValue: Bool {return self._altValue != nil}
  /// Clears the value of `altValue`. Subsequent reads from it will return its default value.
  public mutating func clearAltValue() {self._altValue = nil}

  public var text: String {
    get {return _text ?? String()}
    set {_text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  public var hasText: Bool {return self._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  public mutating func clearText() {self._text = nil}

  public var type: String {
    get {return _type ?? String()}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {self._type = nil}

  public var tid: String {
    get {return _tid ?? String()}
    set {_tid = newValue}
  }
  /// Returns true if `tid` has been explicitly set.
  public var hasTid: Bool {return self._tid != nil}
  /// Clears the value of `tid`. Subsequent reads from it will return its default value.
  public mutating func clearTid() {self._tid = nil}

  public var beginPoint: UInt32 {
    get {return _beginPoint ?? 0}
    set {_beginPoint = newValue}
  }
  /// Returns true if `beginPoint` has been explicitly set.
  public var hasBeginPoint: Bool {return self._beginPoint != nil}
  /// Clears the value of `beginPoint`. Subsequent reads from it will return its default value.
  public mutating func clearBeginPoint() {self._beginPoint = nil}

  public var endPoint: UInt32 {
    get {return _endPoint ?? 0}
    set {_endPoint = newValue}
  }
  /// Returns true if `endPoint` has been explicitly set.
  public var hasEndPoint: Bool {return self._endPoint != nil}
  /// Clears the value of `endPoint`. Subsequent reads from it will return its default value.
  public mutating func clearEndPoint() {self._endPoint = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _value: String? = nil
  fileprivate var _altValue: String? = nil
  fileprivate var _text: String? = nil
  fileprivate var _type: String? = nil
  fileprivate var _tid: String? = nil
  fileprivate var _beginPoint: UInt32? = nil
  fileprivate var _endPoint: UInt32? = nil
}

///
/// A representation of an entity in a relation.
/// This corresponds to the EntityMention, and more broadly the
/// ExtractionObject classes.
public struct Edu_Stanford_Nlp_Pipeline_Entity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var headStart: UInt32 {
    get {return _headStart ?? 0}
    set {_headStart = newValue}
  }
  /// Returns true if `headStart` has been explicitly set.
  public var hasHeadStart: Bool {return self._headStart != nil}
  /// Clears the value of `headStart`. Subsequent reads from it will return its default value.
  public mutating func clearHeadStart() {self._headStart = nil}

  public var headEnd: UInt32 {
    get {return _headEnd ?? 0}
    set {_headEnd = newValue}
  }
  /// Returns true if `headEnd` has been explicitly set.
  public var hasHeadEnd: Bool {return self._headEnd != nil}
  /// Clears the value of `headEnd`. Subsequent reads from it will return its default value.
  public mutating func clearHeadEnd() {self._headEnd = nil}

  public var mentionType: String {
    get {return _mentionType ?? String()}
    set {_mentionType = newValue}
  }
  /// Returns true if `mentionType` has been explicitly set.
  public var hasMentionType: Bool {return self._mentionType != nil}
  /// Clears the value of `mentionType`. Subsequent reads from it will return its default value.
  public mutating func clearMentionType() {self._mentionType = nil}

  public var normalizedName: String {
    get {return _normalizedName ?? String()}
    set {_normalizedName = newValue}
  }
  /// Returns true if `normalizedName` has been explicitly set.
  public var hasNormalizedName: Bool {return self._normalizedName != nil}
  /// Clears the value of `normalizedName`. Subsequent reads from it will return its default value.
  public mutating func clearNormalizedName() {self._normalizedName = nil}

  public var headTokenIndex: UInt32 {
    get {return _headTokenIndex ?? 0}
    set {_headTokenIndex = newValue}
  }
  /// Returns true if `headTokenIndex` has been explicitly set.
  public var hasHeadTokenIndex: Bool {return self._headTokenIndex != nil}
  /// Clears the value of `headTokenIndex`. Subsequent reads from it will return its default value.
  public mutating func clearHeadTokenIndex() {self._headTokenIndex = nil}

  public var corefID: String {
    get {return _corefID ?? String()}
    set {_corefID = newValue}
  }
  /// Returns true if `corefID` has been explicitly set.
  public var hasCorefID: Bool {return self._corefID != nil}
  /// Clears the value of `corefID`. Subsequent reads from it will return its default value.
  public mutating func clearCorefID() {self._corefID = nil}

  /// inherited from ExtractionObject
  public var objectID: String {
    get {return _objectID ?? String()}
    set {_objectID = newValue}
  }
  /// Returns true if `objectID` has been explicitly set.
  public var hasObjectID: Bool {return self._objectID != nil}
  /// Clears the value of `objectID`. Subsequent reads from it will return its default value.
  public mutating func clearObjectID() {self._objectID = nil}

  public var extentStart: UInt32 {
    get {return _extentStart ?? 0}
    set {_extentStart = newValue}
  }
  /// Returns true if `extentStart` has been explicitly set.
  public var hasExtentStart: Bool {return self._extentStart != nil}
  /// Clears the value of `extentStart`. Subsequent reads from it will return its default value.
  public mutating func clearExtentStart() {self._extentStart = nil}

  public var extentEnd: UInt32 {
    get {return _extentEnd ?? 0}
    set {_extentEnd = newValue}
  }
  /// Returns true if `extentEnd` has been explicitly set.
  public var hasExtentEnd: Bool {return self._extentEnd != nil}
  /// Clears the value of `extentEnd`. Subsequent reads from it will return its default value.
  public mutating func clearExtentEnd() {self._extentEnd = nil}

  public var type: String {
    get {return _type ?? String()}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {self._type = nil}

  /// Implicit
  ///       uint32 sentence       @see implicit in sentence
  public var subtype: String {
    get {return _subtype ?? String()}
    set {_subtype = newValue}
  }
  /// Returns true if `subtype` has been explicitly set.
  public var hasSubtype: Bool {return self._subtype != nil}
  /// Clears the value of `subtype`. Subsequent reads from it will return its default value.
  public mutating func clearSubtype() {self._subtype = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _headStart: UInt32? = nil
  fileprivate var _headEnd: UInt32? = nil
  fileprivate var _mentionType: String? = nil
  fileprivate var _normalizedName: String? = nil
  fileprivate var _headTokenIndex: UInt32? = nil
  fileprivate var _corefID: String? = nil
  fileprivate var _objectID: String? = nil
  fileprivate var _extentStart: UInt32? = nil
  fileprivate var _extentEnd: UInt32? = nil
  fileprivate var _type: String? = nil
  fileprivate var _subtype: String? = nil
}

///
/// A representation of a relation, mirroring RelationMention
public struct Edu_Stanford_Nlp_Pipeline_Relation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var argName: [String] = []

  public var arg: [Edu_Stanford_Nlp_Pipeline_Entity] = []

  public var signature: String {
    get {return _signature ?? String()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  /// inherited from ExtractionObject
  public var objectID: String {
    get {return _objectID ?? String()}
    set {_objectID = newValue}
  }
  /// Returns true if `objectID` has been explicitly set.
  public var hasObjectID: Bool {return self._objectID != nil}
  /// Clears the value of `objectID`. Subsequent reads from it will return its default value.
  public mutating func clearObjectID() {self._objectID = nil}

  public var extentStart: UInt32 {
    get {return _extentStart ?? 0}
    set {_extentStart = newValue}
  }
  /// Returns true if `extentStart` has been explicitly set.
  public var hasExtentStart: Bool {return self._extentStart != nil}
  /// Clears the value of `extentStart`. Subsequent reads from it will return its default value.
  public mutating func clearExtentStart() {self._extentStart = nil}

  public var extentEnd: UInt32 {
    get {return _extentEnd ?? 0}
    set {_extentEnd = newValue}
  }
  /// Returns true if `extentEnd` has been explicitly set.
  public var hasExtentEnd: Bool {return self._extentEnd != nil}
  /// Clears the value of `extentEnd`. Subsequent reads from it will return its default value.
  public mutating func clearExtentEnd() {self._extentEnd = nil}

  public var type: String {
    get {return _type ?? String()}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {self._type = nil}

  /// Implicit
  ///       uint32 sentence       @see implicit in sentence
  public var subtype: String {
    get {return _subtype ?? String()}
    set {_subtype = newValue}
  }
  /// Returns true if `subtype` has been explicitly set.
  public var hasSubtype: Bool {return self._subtype != nil}
  /// Clears the value of `subtype`. Subsequent reads from it will return its default value.
  public mutating func clearSubtype() {self._subtype = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _signature: String? = nil
  fileprivate var _objectID: String? = nil
  fileprivate var _extentStart: UInt32? = nil
  fileprivate var _extentEnd: UInt32? = nil
  fileprivate var _type: String? = nil
  fileprivate var _subtype: String? = nil
}

///
/// A Natural Logic operator
public struct Edu_Stanford_Nlp_Pipeline_Operator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  public var quantifierSpanBegin: Int32 {
    get {return _quantifierSpanBegin ?? 0}
    set {_quantifierSpanBegin = newValue}
  }
  /// Returns true if `quantifierSpanBegin` has been explicitly set.
  public var hasQuantifierSpanBegin: Bool {return self._quantifierSpanBegin != nil}
  /// Clears the value of `quantifierSpanBegin`. Subsequent reads from it will return its default value.
  public mutating func clearQuantifierSpanBegin() {self._quantifierSpanBegin = nil}

  public var quantifierSpanEnd: Int32 {
    get {return _quantifierSpanEnd ?? 0}
    set {_quantifierSpanEnd = newValue}
  }
  /// Returns true if `quantifierSpanEnd` has been explicitly set.
  public var hasQuantifierSpanEnd: Bool {return self._quantifierSpanEnd != nil}
  /// Clears the value of `quantifierSpanEnd`. Subsequent reads from it will return its default value.
  public mutating func clearQuantifierSpanEnd() {self._quantifierSpanEnd = nil}

  public var subjectSpanBegin: Int32 {
    get {return _subjectSpanBegin ?? 0}
    set {_subjectSpanBegin = newValue}
  }
  /// Returns true if `subjectSpanBegin` has been explicitly set.
  public var hasSubjectSpanBegin: Bool {return self._subjectSpanBegin != nil}
  /// Clears the value of `subjectSpanBegin`. Subsequent reads from it will return its default value.
  public mutating func clearSubjectSpanBegin() {self._subjectSpanBegin = nil}

  public var subjectSpanEnd: Int32 {
    get {return _subjectSpanEnd ?? 0}
    set {_subjectSpanEnd = newValue}
  }
  /// Returns true if `subjectSpanEnd` has been explicitly set.
  public var hasSubjectSpanEnd: Bool {return self._subjectSpanEnd != nil}
  /// Clears the value of `subjectSpanEnd`. Subsequent reads from it will return its default value.
  public mutating func clearSubjectSpanEnd() {self._subjectSpanEnd = nil}

  public var objectSpanBegin: Int32 {
    get {return _objectSpanBegin ?? 0}
    set {_objectSpanBegin = newValue}
  }
  /// Returns true if `objectSpanBegin` has been explicitly set.
  public var hasObjectSpanBegin: Bool {return self._objectSpanBegin != nil}
  /// Clears the value of `objectSpanBegin`. Subsequent reads from it will return its default value.
  public mutating func clearObjectSpanBegin() {self._objectSpanBegin = nil}

  public var objectSpanEnd: Int32 {
    get {return _objectSpanEnd ?? 0}
    set {_objectSpanEnd = newValue}
  }
  /// Returns true if `objectSpanEnd` has been explicitly set.
  public var hasObjectSpanEnd: Bool {return self._objectSpanEnd != nil}
  /// Clears the value of `objectSpanEnd`. Subsequent reads from it will return its default value.
  public mutating func clearObjectSpanEnd() {self._objectSpanEnd = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _name: String? = nil
  fileprivate var _quantifierSpanBegin: Int32? = nil
  fileprivate var _quantifierSpanEnd: Int32? = nil
  fileprivate var _subjectSpanBegin: Int32? = nil
  fileprivate var _subjectSpanEnd: Int32? = nil
  fileprivate var _objectSpanBegin: Int32? = nil
  fileprivate var _objectSpanEnd: Int32? = nil
}

///
/// The polarity of a word, according to Natural Logic
public struct Edu_Stanford_Nlp_Pipeline_Polarity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var projectEquivalence: Edu_Stanford_Nlp_Pipeline_NaturalLogicRelation {
    get {return _projectEquivalence ?? .equivalence}
    set {_projectEquivalence = newValue}
  }
  /// Returns true if `projectEquivalence` has been explicitly set.
  public var hasProjectEquivalence: Bool {return self._projectEquivalence != nil}
  /// Clears the value of `projectEquivalence`. Subsequent reads from it will return its default value.
  public mutating func clearProjectEquivalence() {self._projectEquivalence = nil}

  public var projectForwardEntailment: Edu_Stanford_Nlp_Pipeline_NaturalLogicRelation {
    get {return _projectForwardEntailment ?? .equivalence}
    set {_projectForwardEntailment = newValue}
  }
  /// Returns true if `projectForwardEntailment` has been explicitly set.
  public var hasProjectForwardEntailment: Bool {return self._projectForwardEntailment != nil}
  /// Clears the value of `projectForwardEntailment`. Subsequent reads from it will return its default value.
  public mutating func clearProjectForwardEntailment() {self._projectForwardEntailment = nil}

  public var projectReverseEntailment: Edu_Stanford_Nlp_Pipeline_NaturalLogicRelation {
    get {return _projectReverseEntailment ?? .equivalence}
    set {_projectReverseEntailment = newValue}
  }
  /// Returns true if `projectReverseEntailment` has been explicitly set.
  public var hasProjectReverseEntailment: Bool {return self._projectReverseEntailment != nil}
  /// Clears the value of `projectReverseEntailment`. Subsequent reads from it will return its default value.
  public mutating func clearProjectReverseEntailment() {self._projectReverseEntailment = nil}

  public var projectNegation: Edu_Stanford_Nlp_Pipeline_NaturalLogicRelation {
    get {return _projectNegation ?? .equivalence}
    set {_projectNegation = newValue}
  }
  /// Returns true if `projectNegation` has been explicitly set.
  public var hasProjectNegation: Bool {return self._projectNegation != nil}
  /// Clears the value of `projectNegation`. Subsequent reads from it will return its default value.
  public mutating func clearProjectNegation() {self._projectNegation = nil}

  public var projectAlternation: Edu_Stanford_Nlp_Pipeline_NaturalLogicRelation {
    get {return _projectAlternation ?? .equivalence}
    set {_projectAlternation = newValue}
  }
  /// Returns true if `projectAlternation` has been explicitly set.
  public var hasProjectAlternation: Bool {return self._projectAlternation != nil}
  /// Clears the value of `projectAlternation`. Subsequent reads from it will return its default value.
  public mutating func clearProjectAlternation() {self._projectAlternation = nil}

  public var projectCover: Edu_Stanford_Nlp_Pipeline_NaturalLogicRelation {
    get {return _projectCover ?? .equivalence}
    set {_projectCover = newValue}
  }
  /// Returns true if `projectCover` has been explicitly set.
  public var hasProjectCover: Bool {return self._projectCover != nil}
  /// Clears the value of `projectCover`. Subsequent reads from it will return its default value.
  public mutating func clearProjectCover() {self._projectCover = nil}

  public var projectIndependence: Edu_Stanford_Nlp_Pipeline_NaturalLogicRelation {
    get {return _projectIndependence ?? .equivalence}
    set {_projectIndependence = newValue}
  }
  /// Returns true if `projectIndependence` has been explicitly set.
  public var hasProjectIndependence: Bool {return self._projectIndependence != nil}
  /// Clears the value of `projectIndependence`. Subsequent reads from it will return its default value.
  public mutating func clearProjectIndependence() {self._projectIndependence = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _projectEquivalence: Edu_Stanford_Nlp_Pipeline_NaturalLogicRelation? = nil
  fileprivate var _projectForwardEntailment: Edu_Stanford_Nlp_Pipeline_NaturalLogicRelation? = nil
  fileprivate var _projectReverseEntailment: Edu_Stanford_Nlp_Pipeline_NaturalLogicRelation? = nil
  fileprivate var _projectNegation: Edu_Stanford_Nlp_Pipeline_NaturalLogicRelation? = nil
  fileprivate var _projectAlternation: Edu_Stanford_Nlp_Pipeline_NaturalLogicRelation? = nil
  fileprivate var _projectCover: Edu_Stanford_Nlp_Pipeline_NaturalLogicRelation? = nil
  fileprivate var _projectIndependence: Edu_Stanford_Nlp_Pipeline_NaturalLogicRelation? = nil
}

///
/// An NER mention in the text
public struct Edu_Stanford_Nlp_Pipeline_NERMention {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sentenceIndex: UInt32 {
    get {return _storage._sentenceIndex ?? 0}
    set {_uniqueStorage()._sentenceIndex = newValue}
  }
  /// Returns true if `sentenceIndex` has been explicitly set.
  public var hasSentenceIndex: Bool {return _storage._sentenceIndex != nil}
  /// Clears the value of `sentenceIndex`. Subsequent reads from it will return its default value.
  public mutating func clearSentenceIndex() {_uniqueStorage()._sentenceIndex = nil}

  public var tokenStartInSentenceInclusive: UInt32 {
    get {return _storage._tokenStartInSentenceInclusive ?? 0}
    set {_uniqueStorage()._tokenStartInSentenceInclusive = newValue}
  }
  /// Returns true if `tokenStartInSentenceInclusive` has been explicitly set.
  public var hasTokenStartInSentenceInclusive: Bool {return _storage._tokenStartInSentenceInclusive != nil}
  /// Clears the value of `tokenStartInSentenceInclusive`. Subsequent reads from it will return its default value.
  public mutating func clearTokenStartInSentenceInclusive() {_uniqueStorage()._tokenStartInSentenceInclusive = nil}

  public var tokenEndInSentenceExclusive: UInt32 {
    get {return _storage._tokenEndInSentenceExclusive ?? 0}
    set {_uniqueStorage()._tokenEndInSentenceExclusive = newValue}
  }
  /// Returns true if `tokenEndInSentenceExclusive` has been explicitly set.
  public var hasTokenEndInSentenceExclusive: Bool {return _storage._tokenEndInSentenceExclusive != nil}
  /// Clears the value of `tokenEndInSentenceExclusive`. Subsequent reads from it will return its default value.
  public mutating func clearTokenEndInSentenceExclusive() {_uniqueStorage()._tokenEndInSentenceExclusive = nil}

  public var ner: String {
    get {return _storage._ner ?? String()}
    set {_uniqueStorage()._ner = newValue}
  }
  /// Returns true if `ner` has been explicitly set.
  public var hasNer: Bool {return _storage._ner != nil}
  /// Clears the value of `ner`. Subsequent reads from it will return its default value.
  public mutating func clearNer() {_uniqueStorage()._ner = nil}

  public var normalizedNer: String {
    get {return _storage._normalizedNer ?? String()}
    set {_uniqueStorage()._normalizedNer = newValue}
  }
  /// Returns true if `normalizedNer` has been explicitly set.
  public var hasNormalizedNer: Bool {return _storage._normalizedNer != nil}
  /// Clears the value of `normalizedNer`. Subsequent reads from it will return its default value.
  public mutating func clearNormalizedNer() {_uniqueStorage()._normalizedNer = nil}

  public var entityType: String {
    get {return _storage._entityType ?? String()}
    set {_uniqueStorage()._entityType = newValue}
  }
  /// Returns true if `entityType` has been explicitly set.
  public var hasEntityType: Bool {return _storage._entityType != nil}
  /// Clears the value of `entityType`. Subsequent reads from it will return its default value.
  public mutating func clearEntityType() {_uniqueStorage()._entityType = nil}

  public var timex: Edu_Stanford_Nlp_Pipeline_Timex {
    get {return _storage._timex ?? Edu_Stanford_Nlp_Pipeline_Timex()}
    set {_uniqueStorage()._timex = newValue}
  }
  /// Returns true if `timex` has been explicitly set.
  public var hasTimex: Bool {return _storage._timex != nil}
  /// Clears the value of `timex`. Subsequent reads from it will return its default value.
  public mutating func clearTimex() {_uniqueStorage()._timex = nil}

  public var wikipediaEntity: String {
    get {return _storage._wikipediaEntity ?? String()}
    set {_uniqueStorage()._wikipediaEntity = newValue}
  }
  /// Returns true if `wikipediaEntity` has been explicitly set.
  public var hasWikipediaEntity: Bool {return _storage._wikipediaEntity != nil}
  /// Clears the value of `wikipediaEntity`. Subsequent reads from it will return its default value.
  public mutating func clearWikipediaEntity() {_uniqueStorage()._wikipediaEntity = nil}

  public var gender: String {
    get {return _storage._gender ?? String()}
    set {_uniqueStorage()._gender = newValue}
  }
  /// Returns true if `gender` has been explicitly set.
  public var hasGender: Bool {return _storage._gender != nil}
  /// Clears the value of `gender`. Subsequent reads from it will return its default value.
  public mutating func clearGender() {_uniqueStorage()._gender = nil}

  public var entityMentionIndex: UInt32 {
    get {return _storage._entityMentionIndex ?? 0}
    set {_uniqueStorage()._entityMentionIndex = newValue}
  }
  /// Returns true if `entityMentionIndex` has been explicitly set.
  public var hasEntityMentionIndex: Bool {return _storage._entityMentionIndex != nil}
  /// Clears the value of `entityMentionIndex`. Subsequent reads from it will return its default value.
  public mutating func clearEntityMentionIndex() {_uniqueStorage()._entityMentionIndex = nil}

  public var canonicalEntityMentionIndex: UInt32 {
    get {return _storage._canonicalEntityMentionIndex ?? 0}
    set {_uniqueStorage()._canonicalEntityMentionIndex = newValue}
  }
  /// Returns true if `canonicalEntityMentionIndex` has been explicitly set.
  public var hasCanonicalEntityMentionIndex: Bool {return _storage._canonicalEntityMentionIndex != nil}
  /// Clears the value of `canonicalEntityMentionIndex`. Subsequent reads from it will return its default value.
  public mutating func clearCanonicalEntityMentionIndex() {_uniqueStorage()._canonicalEntityMentionIndex = nil}

  public var entityMentionText: String {
    get {return _storage._entityMentionText ?? String()}
    set {_uniqueStorage()._entityMentionText = newValue}
  }
  /// Returns true if `entityMentionText` has been explicitly set.
  public var hasEntityMentionText: Bool {return _storage._entityMentionText != nil}
  /// Clears the value of `entityMentionText`. Subsequent reads from it will return its default value.
  public mutating func clearEntityMentionText() {_uniqueStorage()._entityMentionText = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///
/// An entailed sentence fragment.
/// Created by the openie annotator.
public struct Edu_Stanford_Nlp_Pipeline_SentenceFragment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tokenIndex: [UInt32] = []

  public var root: UInt32 {
    get {return _root ?? 0}
    set {_root = newValue}
  }
  /// Returns true if `root` has been explicitly set.
  public var hasRoot: Bool {return self._root != nil}
  /// Clears the value of `root`. Subsequent reads from it will return its default value.
  public mutating func clearRoot() {self._root = nil}

  public var assumedTruth: Bool {
    get {return _assumedTruth ?? false}
    set {_assumedTruth = newValue}
  }
  /// Returns true if `assumedTruth` has been explicitly set.
  public var hasAssumedTruth: Bool {return self._assumedTruth != nil}
  /// Clears the value of `assumedTruth`. Subsequent reads from it will return its default value.
  public mutating func clearAssumedTruth() {self._assumedTruth = nil}

  public var score: Double {
    get {return _score ?? 0}
    set {_score = newValue}
  }
  /// Returns true if `score` has been explicitly set.
  public var hasScore: Bool {return self._score != nil}
  /// Clears the value of `score`. Subsequent reads from it will return its default value.
  public mutating func clearScore() {self._score = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _root: UInt32? = nil
  fileprivate var _assumedTruth: Bool? = nil
  fileprivate var _score: Double? = nil
}

///
/// The index of a token in a document, including the sentence
/// index and the offset.
public struct Edu_Stanford_Nlp_Pipeline_TokenLocation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sentenceIndex: UInt32 {
    get {return _sentenceIndex ?? 0}
    set {_sentenceIndex = newValue}
  }
  /// Returns true if `sentenceIndex` has been explicitly set.
  public var hasSentenceIndex: Bool {return self._sentenceIndex != nil}
  /// Clears the value of `sentenceIndex`. Subsequent reads from it will return its default value.
  public mutating func clearSentenceIndex() {self._sentenceIndex = nil}

  public var tokenIndex: UInt32 {
    get {return _tokenIndex ?? 0}
    set {_tokenIndex = newValue}
  }
  /// Returns true if `tokenIndex` has been explicitly set.
  public var hasTokenIndex: Bool {return self._tokenIndex != nil}
  /// Clears the value of `tokenIndex`. Subsequent reads from it will return its default value.
  public mutating func clearTokenIndex() {self._tokenIndex = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sentenceIndex: UInt32? = nil
  fileprivate var _tokenIndex: UInt32? = nil
}

///
/// An OpenIE relation triple.
/// Created by the openie annotator.
public struct Edu_Stanford_Nlp_Pipeline_RelationTriple {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The surface form of the subject
  public var subject: String {
    get {return _subject ?? String()}
    set {_subject = newValue}
  }
  /// Returns true if `subject` has been explicitly set.
  public var hasSubject: Bool {return self._subject != nil}
  /// Clears the value of `subject`. Subsequent reads from it will return its default value.
  public mutating func clearSubject() {self._subject = nil}

  /// The surface form of the relation (required)
  public var relation: String {
    get {return _relation ?? String()}
    set {_relation = newValue}
  }
  /// Returns true if `relation` has been explicitly set.
  public var hasRelation: Bool {return self._relation != nil}
  /// Clears the value of `relation`. Subsequent reads from it will return its default value.
  public mutating func clearRelation() {self._relation = nil}

  /// The surface form of the object
  public var object: String {
    get {return _object ?? String()}
    set {_object = newValue}
  }
  /// Returns true if `object` has been explicitly set.
  public var hasObject: Bool {return self._object != nil}
  /// Clears the value of `object`. Subsequent reads from it will return its default value.
  public mutating func clearObject() {self._object = nil}

  /// The [optional] confidence of the extraction
  public var confidence: Double {
    get {return _confidence ?? 0}
    set {_confidence = newValue}
  }
  /// Returns true if `confidence` has been explicitly set.
  public var hasConfidence: Bool {return self._confidence != nil}
  /// Clears the value of `confidence`. Subsequent reads from it will return its default value.
  public mutating func clearConfidence() {self._confidence = nil}

  /// The tokens comprising the subject of the triple
  public var subjectTokens: [Edu_Stanford_Nlp_Pipeline_TokenLocation] = []

  /// The tokens comprising the relation of the triple
  public var relationTokens: [Edu_Stanford_Nlp_Pipeline_TokenLocation] = []

  /// The tokens comprising the object of the triple
  public var objectTokens: [Edu_Stanford_Nlp_Pipeline_TokenLocation] = []

  /// The dependency graph fragment for this triple
  public var tree: Edu_Stanford_Nlp_Pipeline_DependencyGraph {
    get {return _tree ?? Edu_Stanford_Nlp_Pipeline_DependencyGraph()}
    set {_tree = newValue}
  }
  /// Returns true if `tree` has been explicitly set.
  public var hasTree: Bool {return self._tree != nil}
  /// Clears the value of `tree`. Subsequent reads from it will return its default value.
  public mutating func clearTree() {self._tree = nil}

  /// If true, this expresses an implicit tmod relation
  public var istmod: Bool {
    get {return _istmod ?? false}
    set {_istmod = newValue}
  }
  /// Returns true if `istmod` has been explicitly set.
  public var hasIstmod: Bool {return self._istmod != nil}
  /// Clears the value of `istmod`. Subsequent reads from it will return its default value.
  public mutating func clearIstmod() {self._istmod = nil}

  /// If true, this relation string is missing a 'be' prefix
  public var prefixBe: Bool {
    get {return _prefixBe ?? false}
    set {_prefixBe = newValue}
  }
  /// Returns true if `prefixBe` has been explicitly set.
  public var hasPrefixBe: Bool {return self._prefixBe != nil}
  /// Clears the value of `prefixBe`. Subsequent reads from it will return its default value.
  public mutating func clearPrefixBe() {self._prefixBe = nil}

  /// If true, this relation string is missing a 'be' suffix
  public var suffixBe: Bool {
    get {return _suffixBe ?? false}
    set {_suffixBe = newValue}
  }
  /// Returns true if `suffixBe` has been explicitly set.
  public var hasSuffixBe: Bool {return self._suffixBe != nil}
  /// Clears the value of `suffixBe`. Subsequent reads from it will return its default value.
  public mutating func clearSuffixBe() {self._suffixBe = nil}

  /// If true, this relation string is missing a 'of' prefix
  public var suffixOf: Bool {
    get {return _suffixOf ?? false}
    set {_suffixOf = newValue}
  }
  /// Returns true if `suffixOf` has been explicitly set.
  public var hasSuffixOf: Bool {return self._suffixOf != nil}
  /// Clears the value of `suffixOf`. Subsequent reads from it will return its default value.
  public mutating func clearSuffixOf() {self._suffixOf = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _subject: String? = nil
  fileprivate var _relation: String? = nil
  fileprivate var _object: String? = nil
  fileprivate var _confidence: Double? = nil
  fileprivate var _tree: Edu_Stanford_Nlp_Pipeline_DependencyGraph? = nil
  fileprivate var _istmod: Bool? = nil
  fileprivate var _prefixBe: Bool? = nil
  fileprivate var _suffixBe: Bool? = nil
  fileprivate var _suffixOf: Bool? = nil
}

///
/// A map from strings to strings.
/// Used, minimally, in the CoNLLU featurizer
public struct Edu_Stanford_Nlp_Pipeline_MapStringString {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: [String] = []

  public var value: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A map from integers to strings.
/// Used, minimally, in the CoNLLU featurizer
public struct Edu_Stanford_Nlp_Pipeline_MapIntString {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: [UInt32] = []

  public var value: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Edu_Stanford_Nlp_Pipeline_Section {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var charBegin: UInt32 {
    get {return _charBegin ?? 0}
    set {_charBegin = newValue}
  }
  /// Returns true if `charBegin` has been explicitly set.
  public var hasCharBegin: Bool {return self._charBegin != nil}
  /// Clears the value of `charBegin`. Subsequent reads from it will return its default value.
  public mutating func clearCharBegin() {self._charBegin = nil}

  public var charEnd: UInt32 {
    get {return _charEnd ?? 0}
    set {_charEnd = newValue}
  }
  /// Returns true if `charEnd` has been explicitly set.
  public var hasCharEnd: Bool {return self._charEnd != nil}
  /// Clears the value of `charEnd`. Subsequent reads from it will return its default value.
  public mutating func clearCharEnd() {self._charEnd = nil}

  public var author: String {
    get {return _author ?? String()}
    set {_author = newValue}
  }
  /// Returns true if `author` has been explicitly set.
  public var hasAuthor: Bool {return self._author != nil}
  /// Clears the value of `author`. Subsequent reads from it will return its default value.
  public mutating func clearAuthor() {self._author = nil}

  public var sentenceIndexes: [UInt32] = []

  public var datetime: String {
    get {return _datetime ?? String()}
    set {_datetime = newValue}
  }
  /// Returns true if `datetime` has been explicitly set.
  public var hasDatetime: Bool {return self._datetime != nil}
  /// Clears the value of `datetime`. Subsequent reads from it will return its default value.
  public mutating func clearDatetime() {self._datetime = nil}

  public var quotes: [Edu_Stanford_Nlp_Pipeline_Quote] = []

  public var authorCharBegin: UInt32 {
    get {return _authorCharBegin ?? 0}
    set {_authorCharBegin = newValue}
  }
  /// Returns true if `authorCharBegin` has been explicitly set.
  public var hasAuthorCharBegin: Bool {return self._authorCharBegin != nil}
  /// Clears the value of `authorCharBegin`. Subsequent reads from it will return its default value.
  public mutating func clearAuthorCharBegin() {self._authorCharBegin = nil}

  public var authorCharEnd: UInt32 {
    get {return _authorCharEnd ?? 0}
    set {_authorCharEnd = newValue}
  }
  /// Returns true if `authorCharEnd` has been explicitly set.
  public var hasAuthorCharEnd: Bool {return self._authorCharEnd != nil}
  /// Clears the value of `authorCharEnd`. Subsequent reads from it will return its default value.
  public mutating func clearAuthorCharEnd() {self._authorCharEnd = nil}

  public var xmlTag: Edu_Stanford_Nlp_Pipeline_Token {
    get {return _xmlTag ?? Edu_Stanford_Nlp_Pipeline_Token()}
    set {_xmlTag = newValue}
  }
  /// Returns true if `xmlTag` has been explicitly set.
  public var hasXmlTag: Bool {return self._xmlTag != nil}
  /// Clears the value of `xmlTag`. Subsequent reads from it will return its default value.
  public mutating func clearXmlTag() {self._xmlTag = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _charBegin: UInt32? = nil
  fileprivate var _charEnd: UInt32? = nil
  fileprivate var _author: String? = nil
  fileprivate var _datetime: String? = nil
  fileprivate var _authorCharBegin: UInt32? = nil
  fileprivate var _authorCharEnd: UInt32? = nil
  fileprivate var _xmlTag: Edu_Stanford_Nlp_Pipeline_Token? = nil
}

/// A message for requesting a semgrex
/// Each sentence stores information about the tokens making up the
/// corresponding graph
/// An alternative would have been to use the existing Document or
/// Sentence classes, but the problem with that is it would be
/// ambiguous which dependency object to use.
public struct Edu_Stanford_Nlp_Pipeline_SemgrexRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var semgrex: [String] = []

  public var query: [Edu_Stanford_Nlp_Pipeline_SemgrexRequest.Dependencies] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Dependencies {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var token: [Edu_Stanford_Nlp_Pipeline_Token] = []

    public var graph: Edu_Stanford_Nlp_Pipeline_DependencyGraph {
      get {return _graph ?? Edu_Stanford_Nlp_Pipeline_DependencyGraph()}
      set {_graph = newValue}
    }
    /// Returns true if `graph` has been explicitly set.
    public var hasGraph: Bool {return self._graph != nil}
    /// Clears the value of `graph`. Subsequent reads from it will return its default value.
    public mutating func clearGraph() {self._graph = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _graph: Edu_Stanford_Nlp_Pipeline_DependencyGraph? = nil
  }

  public init() {}
}

/// The response from running a semgrex
/// If you pass in M semgrex expressions and N dependency graphs,
/// this returns MxN nested results.  Each SemgrexResult can match
/// multiple times in one graph
public struct Edu_Stanford_Nlp_Pipeline_SemgrexResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: [Edu_Stanford_Nlp_Pipeline_SemgrexResponse.GraphResult] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct NamedNode {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var name: String {
      get {return _name ?? String()}
      set {_name = newValue}
    }
    /// Returns true if `name` has been explicitly set.
    public var hasName: Bool {return self._name != nil}
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    public mutating func clearName() {self._name = nil}

    public var matchIndex: Int32 {
      get {return _matchIndex ?? 0}
      set {_matchIndex = newValue}
    }
    /// Returns true if `matchIndex` has been explicitly set.
    public var hasMatchIndex: Bool {return self._matchIndex != nil}
    /// Clears the value of `matchIndex`. Subsequent reads from it will return its default value.
    public mutating func clearMatchIndex() {self._matchIndex = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _name: String? = nil
    fileprivate var _matchIndex: Int32? = nil
  }

  public struct NamedRelation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var name: String {
      get {return _name ?? String()}
      set {_name = newValue}
    }
    /// Returns true if `name` has been explicitly set.
    public var hasName: Bool {return self._name != nil}
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    public mutating func clearName() {self._name = nil}

    public var reln: String {
      get {return _reln ?? String()}
      set {_reln = newValue}
    }
    /// Returns true if `reln` has been explicitly set.
    public var hasReln: Bool {return self._reln != nil}
    /// Clears the value of `reln`. Subsequent reads from it will return its default value.
    public mutating func clearReln() {self._reln = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _name: String? = nil
    fileprivate var _reln: String? = nil
  }

  public struct Match {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var matchIndex: Int32 {
      get {return _matchIndex ?? 0}
      set {_matchIndex = newValue}
    }
    /// Returns true if `matchIndex` has been explicitly set.
    public var hasMatchIndex: Bool {return self._matchIndex != nil}
    /// Clears the value of `matchIndex`. Subsequent reads from it will return its default value.
    public mutating func clearMatchIndex() {self._matchIndex = nil}

    public var node: [Edu_Stanford_Nlp_Pipeline_SemgrexResponse.NamedNode] = []

    public var reln: [Edu_Stanford_Nlp_Pipeline_SemgrexResponse.NamedRelation] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _matchIndex: Int32? = nil
  }

  public struct SemgrexResult {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var match: [Edu_Stanford_Nlp_Pipeline_SemgrexResponse.Match] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct GraphResult {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var result: [Edu_Stanford_Nlp_Pipeline_SemgrexResponse.SemgrexResult] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// It's possible to send in a whole document, but we
/// only care about the Sentences and Tokens
public struct Edu_Stanford_Nlp_Pipeline_TokensRegexRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var doc: Edu_Stanford_Nlp_Pipeline_Document {
    get {return _doc ?? Edu_Stanford_Nlp_Pipeline_Document()}
    set {_doc = newValue}
  }
  /// Returns true if `doc` has been explicitly set.
  public var hasDoc: Bool {return self._doc != nil}
  /// Clears the value of `doc`. Subsequent reads from it will return its default value.
  public mutating func clearDoc() {self._doc = nil}

  public var pattern: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _doc: Edu_Stanford_Nlp_Pipeline_Document? = nil
}

/// The result will be a nested structure:
/// repeated PatternMatch, one for each pattern
/// each PatternMatch has a repeated Match,
///   which tells you which sentence matched and where
public struct Edu_Stanford_Nlp_Pipeline_TokensRegexResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var match: [Edu_Stanford_Nlp_Pipeline_TokensRegexResponse.PatternMatch] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct MatchLocation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var text: String {
      get {return _text ?? String()}
      set {_text = newValue}
    }
    /// Returns true if `text` has been explicitly set.
    public var hasText: Bool {return self._text != nil}
    /// Clears the value of `text`. Subsequent reads from it will return its default value.
    public mutating func clearText() {self._text = nil}

    public var begin: Int32 {
      get {return _begin ?? 0}
      set {_begin = newValue}
    }
    /// Returns true if `begin` has been explicitly set.
    public var hasBegin: Bool {return self._begin != nil}
    /// Clears the value of `begin`. Subsequent reads from it will return its default value.
    public mutating func clearBegin() {self._begin = nil}

    public var end: Int32 {
      get {return _end ?? 0}
      set {_end = newValue}
    }
    /// Returns true if `end` has been explicitly set.
    public var hasEnd: Bool {return self._end != nil}
    /// Clears the value of `end`. Subsequent reads from it will return its default value.
    public mutating func clearEnd() {self._end = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _text: String? = nil
    fileprivate var _begin: Int32? = nil
    fileprivate var _end: Int32? = nil
  }

  public struct Match {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var sentence: Int32 {
      get {return _sentence ?? 0}
      set {_sentence = newValue}
    }
    /// Returns true if `sentence` has been explicitly set.
    public var hasSentence: Bool {return self._sentence != nil}
    /// Clears the value of `sentence`. Subsequent reads from it will return its default value.
    public mutating func clearSentence() {self._sentence = nil}

    public var match: Edu_Stanford_Nlp_Pipeline_TokensRegexResponse.MatchLocation {
      get {return _match ?? Edu_Stanford_Nlp_Pipeline_TokensRegexResponse.MatchLocation()}
      set {_match = newValue}
    }
    /// Returns true if `match` has been explicitly set.
    public var hasMatch: Bool {return self._match != nil}
    /// Clears the value of `match`. Subsequent reads from it will return its default value.
    public mutating func clearMatch() {self._match = nil}

    public var group: [Edu_Stanford_Nlp_Pipeline_TokensRegexResponse.MatchLocation] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _sentence: Int32? = nil
    fileprivate var _match: Edu_Stanford_Nlp_Pipeline_TokensRegexResponse.MatchLocation? = nil
  }

  public struct PatternMatch {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var match: [Edu_Stanford_Nlp_Pipeline_TokensRegexResponse.Match] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "edu.stanford.nlp.pipeline"

extension Edu_Stanford_Nlp_Pipeline_Language: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Unknown"),
    1: .same(proto: "Any"),
    2: .same(proto: "Arabic"),
    3: .same(proto: "Chinese"),
    4: .same(proto: "English"),
    5: .same(proto: "German"),
    6: .same(proto: "French"),
    7: .same(proto: "Hebrew"),
    8: .same(proto: "Spanish"),
    9: .same(proto: "UniversalEnglish"),
    10: .same(proto: "UniversalChinese"),
  ]
}

extension Edu_Stanford_Nlp_Pipeline_Sentiment: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STRONG_NEGATIVE"),
    1: .same(proto: "WEAK_NEGATIVE"),
    2: .same(proto: "NEUTRAL"),
    3: .same(proto: "WEAK_POSITIVE"),
    4: .same(proto: "STRONG_POSITIVE"),
  ]
}

extension Edu_Stanford_Nlp_Pipeline_NaturalLogicRelation: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EQUIVALENCE"),
    1: .same(proto: "FORWARD_ENTAILMENT"),
    2: .same(proto: "REVERSE_ENTAILMENT"),
    3: .same(proto: "NEGATION"),
    4: .same(proto: "ALTERNATION"),
    5: .same(proto: "COVER"),
    6: .same(proto: "INDEPENDENCE"),
  ]
}

extension Edu_Stanford_Nlp_Pipeline_Document: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Document"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "sentence"),
    3: .same(proto: "corefChain"),
    4: .same(proto: "docID"),
    7: .same(proto: "docDate"),
    8: .same(proto: "calendar"),
    5: .same(proto: "sentencelessToken"),
    10: .same(proto: "character"),
    6: .same(proto: "quote"),
    9: .same(proto: "mentions"),
    13: .same(proto: "hasEntityMentionsAnnotation"),
    11: .same(proto: "xmlDoc"),
    12: .same(proto: "sections"),
    14: .same(proto: "mentionsForCoref"),
    15: .same(proto: "hasCorefMentionAnnotation"),
    16: .same(proto: "hasCorefAnnotation"),
    17: .same(proto: "corefMentionToEntityMentionMappings"),
    18: .same(proto: "entityMentionToCorefMentionMappings"),
  ]

  fileprivate class _StorageClass {
    var _text: String? = nil
    var _sentence: [Edu_Stanford_Nlp_Pipeline_Sentence] = []
    var _corefChain: [Edu_Stanford_Nlp_Pipeline_CorefChain] = []
    var _docID: String? = nil
    var _docDate: String? = nil
    var _calendar: UInt64? = nil
    var _sentencelessToken: [Edu_Stanford_Nlp_Pipeline_Token] = []
    var _character: [Edu_Stanford_Nlp_Pipeline_Token] = []
    var _quote: [Edu_Stanford_Nlp_Pipeline_Quote] = []
    var _mentions: [Edu_Stanford_Nlp_Pipeline_NERMention] = []
    var _hasEntityMentionsAnnotation_p: Bool? = nil
    var _xmlDoc: Bool? = nil
    var _sections: [Edu_Stanford_Nlp_Pipeline_Section] = []
    var _mentionsForCoref: [Edu_Stanford_Nlp_Pipeline_Mention] = []
    var _hasCorefMentionAnnotation_p: Bool? = nil
    var _hasCorefAnnotation_p: Bool? = nil
    var _corefMentionToEntityMentionMappings: [Int32] = []
    var _entityMentionToCorefMentionMappings: [Int32] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _text = source._text
      _sentence = source._sentence
      _corefChain = source._corefChain
      _docID = source._docID
      _docDate = source._docDate
      _calendar = source._calendar
      _sentencelessToken = source._sentencelessToken
      _character = source._character
      _quote = source._quote
      _mentions = source._mentions
      _hasEntityMentionsAnnotation_p = source._hasEntityMentionsAnnotation_p
      _xmlDoc = source._xmlDoc
      _sections = source._sections
      _mentionsForCoref = source._mentionsForCoref
      _hasCorefMentionAnnotation_p = source._hasCorefMentionAnnotation_p
      _hasCorefAnnotation_p = source._hasCorefAnnotation_p
      _corefMentionToEntityMentionMappings = source._corefMentionToEntityMentionMappings
      _entityMentionToCorefMentionMappings = source._entityMentionToCorefMentionMappings
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._text == nil {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._sentence) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._corefChain) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._sentencelessToken) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._character) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._quote) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._mentions) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._sections) {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._text) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._sentence) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._corefChain) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._docID) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._sentencelessToken) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._quote) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._docDate) }()
        case 8: try { try decoder.decodeSingularUInt64Field(value: &_storage._calendar) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._mentions) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._character) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._xmlDoc) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._sections) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._hasEntityMentionsAnnotation_p) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._mentionsForCoref) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._hasCorefMentionAnnotation_p) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._hasCorefAnnotation_p) }()
        case 17: try { try decoder.decodeRepeatedInt32Field(value: &_storage._corefMentionToEntityMentionMappings) }()
        case 18: try { try decoder.decodeRepeatedInt32Field(value: &_storage._entityMentionToCorefMentionMappings) }()
        case 100..<256:
          try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: Edu_Stanford_Nlp_Pipeline_Document.self, fieldNumber: fieldNumber) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._text {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if !_storage._sentence.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._sentence, fieldNumber: 2)
      }
      if !_storage._corefChain.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._corefChain, fieldNumber: 3)
      }
      if let v = _storage._docID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
      if !_storage._sentencelessToken.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._sentencelessToken, fieldNumber: 5)
      }
      if !_storage._quote.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._quote, fieldNumber: 6)
      }
      if let v = _storage._docDate {
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      }
      if let v = _storage._calendar {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 8)
      }
      if !_storage._mentions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._mentions, fieldNumber: 9)
      }
      if !_storage._character.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._character, fieldNumber: 10)
      }
      if let v = _storage._xmlDoc {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
      }
      if !_storage._sections.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._sections, fieldNumber: 12)
      }
      if let v = _storage._hasEntityMentionsAnnotation_p {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
      }
      if !_storage._mentionsForCoref.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._mentionsForCoref, fieldNumber: 14)
      }
      if let v = _storage._hasCorefMentionAnnotation_p {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 15)
      }
      if let v = _storage._hasCorefAnnotation_p {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 16)
      }
      if !_storage._corefMentionToEntityMentionMappings.isEmpty {
        try visitor.visitRepeatedInt32Field(value: _storage._corefMentionToEntityMentionMappings, fieldNumber: 17)
      }
      if !_storage._entityMentionToCorefMentionMappings.isEmpty {
        try visitor.visitRepeatedInt32Field(value: _storage._entityMentionToCorefMentionMappings, fieldNumber: 18)
      }
      try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 100, end: 256)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_Document, rhs: Edu_Stanford_Nlp_Pipeline_Document) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._text != rhs_storage._text {return false}
        if _storage._sentence != rhs_storage._sentence {return false}
        if _storage._corefChain != rhs_storage._corefChain {return false}
        if _storage._docID != rhs_storage._docID {return false}
        if _storage._docDate != rhs_storage._docDate {return false}
        if _storage._calendar != rhs_storage._calendar {return false}
        if _storage._sentencelessToken != rhs_storage._sentencelessToken {return false}
        if _storage._character != rhs_storage._character {return false}
        if _storage._quote != rhs_storage._quote {return false}
        if _storage._mentions != rhs_storage._mentions {return false}
        if _storage._hasEntityMentionsAnnotation_p != rhs_storage._hasEntityMentionsAnnotation_p {return false}
        if _storage._xmlDoc != rhs_storage._xmlDoc {return false}
        if _storage._sections != rhs_storage._sections {return false}
        if _storage._mentionsForCoref != rhs_storage._mentionsForCoref {return false}
        if _storage._hasCorefMentionAnnotation_p != rhs_storage._hasCorefMentionAnnotation_p {return false}
        if _storage._hasCorefAnnotation_p != rhs_storage._hasCorefAnnotation_p {return false}
        if _storage._corefMentionToEntityMentionMappings != rhs_storage._corefMentionToEntityMentionMappings {return false}
        if _storage._entityMentionToCorefMentionMappings != rhs_storage._entityMentionToCorefMentionMappings {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension Edu_Stanford_Nlp_Pipeline_Sentence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Sentence"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "tokenOffsetBegin"),
    3: .same(proto: "tokenOffsetEnd"),
    4: .same(proto: "sentenceIndex"),
    5: .same(proto: "characterOffsetBegin"),
    6: .same(proto: "characterOffsetEnd"),
    7: .same(proto: "parseTree"),
    31: .same(proto: "binarizedParseTree"),
    32: .same(proto: "annotatedParseTree"),
    33: .same(proto: "sentiment"),
    34: .same(proto: "kBestParseTrees"),
    8: .same(proto: "basicDependencies"),
    9: .same(proto: "collapsedDependencies"),
    10: .same(proto: "collapsedCCProcessedDependencies"),
    13: .same(proto: "alternativeDependencies"),
    14: .same(proto: "openieTriple"),
    16: .same(proto: "kbpTriple"),
    15: .same(proto: "entailedSentence"),
    35: .same(proto: "entailedClause"),
    17: .same(proto: "enhancedDependencies"),
    18: .same(proto: "enhancedPlusPlusDependencies"),
    19: .same(proto: "character"),
    11: .same(proto: "paragraph"),
    12: .same(proto: "text"),
    20: .same(proto: "lineNumber"),
    51: .same(proto: "hasRelationAnnotations"),
    52: .same(proto: "entity"),
    53: .same(proto: "relation"),
    54: .same(proto: "hasNumerizedTokensAnnotation"),
    55: .same(proto: "mentions"),
    56: .same(proto: "mentionsForCoref"),
    57: .same(proto: "hasCorefMentionsAnnotation"),
    58: .same(proto: "sentenceID"),
    59: .same(proto: "sectionDate"),
    60: .same(proto: "sectionIndex"),
    61: .same(proto: "sectionName"),
    62: .same(proto: "sectionAuthor"),
    63: .same(proto: "docID"),
    64: .same(proto: "sectionQuoted"),
    65: .same(proto: "hasEntityMentionsAnnotation"),
    68: .same(proto: "hasKBPTriplesAnnotation"),
    69: .same(proto: "hasOpenieTriplesAnnotation"),
    66: .same(proto: "chapterIndex"),
    67: .same(proto: "paragraphIndex"),
    70: .same(proto: "enhancedSentence"),
    71: .same(proto: "speaker"),
    72: .same(proto: "speakerType"),
  ]

  fileprivate class _StorageClass {
    var _token: [Edu_Stanford_Nlp_Pipeline_Token] = []
    var _tokenOffsetBegin: UInt32? = nil
    var _tokenOffsetEnd: UInt32? = nil
    var _sentenceIndex: UInt32? = nil
    var _characterOffsetBegin: UInt32? = nil
    var _characterOffsetEnd: UInt32? = nil
    var _parseTree: Edu_Stanford_Nlp_Pipeline_ParseTree? = nil
    var _binarizedParseTree: Edu_Stanford_Nlp_Pipeline_ParseTree? = nil
    var _annotatedParseTree: Edu_Stanford_Nlp_Pipeline_ParseTree? = nil
    var _sentiment: String? = nil
    var _kBestParseTrees: [Edu_Stanford_Nlp_Pipeline_ParseTree] = []
    var _basicDependencies: Edu_Stanford_Nlp_Pipeline_DependencyGraph? = nil
    var _collapsedDependencies: Edu_Stanford_Nlp_Pipeline_DependencyGraph? = nil
    var _collapsedCcprocessedDependencies: Edu_Stanford_Nlp_Pipeline_DependencyGraph? = nil
    var _alternativeDependencies: Edu_Stanford_Nlp_Pipeline_DependencyGraph? = nil
    var _openieTriple: [Edu_Stanford_Nlp_Pipeline_RelationTriple] = []
    var _kbpTriple: [Edu_Stanford_Nlp_Pipeline_RelationTriple] = []
    var _entailedSentence: [Edu_Stanford_Nlp_Pipeline_SentenceFragment] = []
    var _entailedClause: [Edu_Stanford_Nlp_Pipeline_SentenceFragment] = []
    var _enhancedDependencies: Edu_Stanford_Nlp_Pipeline_DependencyGraph? = nil
    var _enhancedPlusPlusDependencies: Edu_Stanford_Nlp_Pipeline_DependencyGraph? = nil
    var _character: [Edu_Stanford_Nlp_Pipeline_Token] = []
    var _paragraph: UInt32? = nil
    var _text: String? = nil
    var _lineNumber: UInt32? = nil
    var _hasRelationAnnotations_p: Bool? = nil
    var _entity: [Edu_Stanford_Nlp_Pipeline_Entity] = []
    var _relation: [Edu_Stanford_Nlp_Pipeline_Relation] = []
    var _hasNumerizedTokensAnnotation_p: Bool? = nil
    var _mentions: [Edu_Stanford_Nlp_Pipeline_NERMention] = []
    var _mentionsForCoref: [Edu_Stanford_Nlp_Pipeline_Mention] = []
    var _hasCorefMentionsAnnotation_p: Bool? = nil
    var _sentenceID: String? = nil
    var _sectionDate: String? = nil
    var _sectionIndex: UInt32? = nil
    var _sectionName: String? = nil
    var _sectionAuthor: String? = nil
    var _docID: String? = nil
    var _sectionQuoted: Bool? = nil
    var _hasEntityMentionsAnnotation_p: Bool? = nil
    var _hasKbptriplesAnnotation_p: Bool? = nil
    var _hasOpenieTriplesAnnotation_p: Bool? = nil
    var _chapterIndex: UInt32? = nil
    var _paragraphIndex: UInt32? = nil
    var _enhancedSentence: Edu_Stanford_Nlp_Pipeline_Sentence? = nil
    var _speaker: String? = nil
    var _speakerType: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _token = source._token
      _tokenOffsetBegin = source._tokenOffsetBegin
      _tokenOffsetEnd = source._tokenOffsetEnd
      _sentenceIndex = source._sentenceIndex
      _characterOffsetBegin = source._characterOffsetBegin
      _characterOffsetEnd = source._characterOffsetEnd
      _parseTree = source._parseTree
      _binarizedParseTree = source._binarizedParseTree
      _annotatedParseTree = source._annotatedParseTree
      _sentiment = source._sentiment
      _kBestParseTrees = source._kBestParseTrees
      _basicDependencies = source._basicDependencies
      _collapsedDependencies = source._collapsedDependencies
      _collapsedCcprocessedDependencies = source._collapsedCcprocessedDependencies
      _alternativeDependencies = source._alternativeDependencies
      _openieTriple = source._openieTriple
      _kbpTriple = source._kbpTriple
      _entailedSentence = source._entailedSentence
      _entailedClause = source._entailedClause
      _enhancedDependencies = source._enhancedDependencies
      _enhancedPlusPlusDependencies = source._enhancedPlusPlusDependencies
      _character = source._character
      _paragraph = source._paragraph
      _text = source._text
      _lineNumber = source._lineNumber
      _hasRelationAnnotations_p = source._hasRelationAnnotations_p
      _entity = source._entity
      _relation = source._relation
      _hasNumerizedTokensAnnotation_p = source._hasNumerizedTokensAnnotation_p
      _mentions = source._mentions
      _mentionsForCoref = source._mentionsForCoref
      _hasCorefMentionsAnnotation_p = source._hasCorefMentionsAnnotation_p
      _sentenceID = source._sentenceID
      _sectionDate = source._sectionDate
      _sectionIndex = source._sectionIndex
      _sectionName = source._sectionName
      _sectionAuthor = source._sectionAuthor
      _docID = source._docID
      _sectionQuoted = source._sectionQuoted
      _hasEntityMentionsAnnotation_p = source._hasEntityMentionsAnnotation_p
      _hasKbptriplesAnnotation_p = source._hasKbptriplesAnnotation_p
      _hasOpenieTriplesAnnotation_p = source._hasOpenieTriplesAnnotation_p
      _chapterIndex = source._chapterIndex
      _paragraphIndex = source._paragraphIndex
      _enhancedSentence = source._enhancedSentence
      _speaker = source._speaker
      _speakerType = source._speakerType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._tokenOffsetBegin == nil {return false}
      if _storage._tokenOffsetEnd == nil {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._token) {return false}
      if let v = _storage._basicDependencies, !v.isInitialized {return false}
      if let v = _storage._collapsedDependencies, !v.isInitialized {return false}
      if let v = _storage._collapsedCcprocessedDependencies, !v.isInitialized {return false}
      if let v = _storage._alternativeDependencies, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._openieTriple) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._kbpTriple) {return false}
      if let v = _storage._enhancedDependencies, !v.isInitialized {return false}
      if let v = _storage._enhancedPlusPlusDependencies, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._character) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._mentions) {return false}
      if let v = _storage._enhancedSentence, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeRepeatedMessageField(value: &_storage._token) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._tokenOffsetBegin) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._tokenOffsetEnd) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._sentenceIndex) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._characterOffsetBegin) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._characterOffsetEnd) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._parseTree) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._basicDependencies) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._collapsedDependencies) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._collapsedCcprocessedDependencies) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._paragraph) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._text) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._alternativeDependencies) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._openieTriple) }()
        case 15: try { try decoder.decodeRepeatedMessageField(value: &_storage._entailedSentence) }()
        case 16: try { try decoder.decodeRepeatedMessageField(value: &_storage._kbpTriple) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._enhancedDependencies) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._enhancedPlusPlusDependencies) }()
        case 19: try { try decoder.decodeRepeatedMessageField(value: &_storage._character) }()
        case 20: try { try decoder.decodeSingularUInt32Field(value: &_storage._lineNumber) }()
        case 31: try { try decoder.decodeSingularMessageField(value: &_storage._binarizedParseTree) }()
        case 32: try { try decoder.decodeSingularMessageField(value: &_storage._annotatedParseTree) }()
        case 33: try { try decoder.decodeSingularStringField(value: &_storage._sentiment) }()
        case 34: try { try decoder.decodeRepeatedMessageField(value: &_storage._kBestParseTrees) }()
        case 35: try { try decoder.decodeRepeatedMessageField(value: &_storage._entailedClause) }()
        case 51: try { try decoder.decodeSingularBoolField(value: &_storage._hasRelationAnnotations_p) }()
        case 52: try { try decoder.decodeRepeatedMessageField(value: &_storage._entity) }()
        case 53: try { try decoder.decodeRepeatedMessageField(value: &_storage._relation) }()
        case 54: try { try decoder.decodeSingularBoolField(value: &_storage._hasNumerizedTokensAnnotation_p) }()
        case 55: try { try decoder.decodeRepeatedMessageField(value: &_storage._mentions) }()
        case 56: try { try decoder.decodeRepeatedMessageField(value: &_storage._mentionsForCoref) }()
        case 57: try { try decoder.decodeSingularBoolField(value: &_storage._hasCorefMentionsAnnotation_p) }()
        case 58: try { try decoder.decodeSingularStringField(value: &_storage._sentenceID) }()
        case 59: try { try decoder.decodeSingularStringField(value: &_storage._sectionDate) }()
        case 60: try { try decoder.decodeSingularUInt32Field(value: &_storage._sectionIndex) }()
        case 61: try { try decoder.decodeSingularStringField(value: &_storage._sectionName) }()
        case 62: try { try decoder.decodeSingularStringField(value: &_storage._sectionAuthor) }()
        case 63: try { try decoder.decodeSingularStringField(value: &_storage._docID) }()
        case 64: try { try decoder.decodeSingularBoolField(value: &_storage._sectionQuoted) }()
        case 65: try { try decoder.decodeSingularBoolField(value: &_storage._hasEntityMentionsAnnotation_p) }()
        case 66: try { try decoder.decodeSingularUInt32Field(value: &_storage._chapterIndex) }()
        case 67: try { try decoder.decodeSingularUInt32Field(value: &_storage._paragraphIndex) }()
        case 68: try { try decoder.decodeSingularBoolField(value: &_storage._hasKbptriplesAnnotation_p) }()
        case 69: try { try decoder.decodeSingularBoolField(value: &_storage._hasOpenieTriplesAnnotation_p) }()
        case 70: try { try decoder.decodeSingularMessageField(value: &_storage._enhancedSentence) }()
        case 71: try { try decoder.decodeSingularStringField(value: &_storage._speaker) }()
        case 72: try { try decoder.decodeSingularStringField(value: &_storage._speakerType) }()
        case 100..<256:
          try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: Edu_Stanford_Nlp_Pipeline_Sentence.self, fieldNumber: fieldNumber) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._token.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._token, fieldNumber: 1)
      }
      if let v = _storage._tokenOffsetBegin {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
      }
      if let v = _storage._tokenOffsetEnd {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
      }
      if let v = _storage._sentenceIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
      }
      if let v = _storage._characterOffsetBegin {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
      }
      if let v = _storage._characterOffsetEnd {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
      }
      if let v = _storage._parseTree {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._basicDependencies {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._collapsedDependencies {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._collapsedCcprocessedDependencies {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._paragraph {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 11)
      }
      if let v = _storage._text {
        try visitor.visitSingularStringField(value: v, fieldNumber: 12)
      }
      if let v = _storage._alternativeDependencies {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if !_storage._openieTriple.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._openieTriple, fieldNumber: 14)
      }
      if !_storage._entailedSentence.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._entailedSentence, fieldNumber: 15)
      }
      if !_storage._kbpTriple.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._kbpTriple, fieldNumber: 16)
      }
      if let v = _storage._enhancedDependencies {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
      if let v = _storage._enhancedPlusPlusDependencies {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }
      if !_storage._character.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._character, fieldNumber: 19)
      }
      if let v = _storage._lineNumber {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 20)
      }
      if let v = _storage._binarizedParseTree {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      }
      if let v = _storage._annotatedParseTree {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      }
      if let v = _storage._sentiment {
        try visitor.visitSingularStringField(value: v, fieldNumber: 33)
      }
      if !_storage._kBestParseTrees.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._kBestParseTrees, fieldNumber: 34)
      }
      if !_storage._entailedClause.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._entailedClause, fieldNumber: 35)
      }
      if let v = _storage._hasRelationAnnotations_p {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 51)
      }
      if !_storage._entity.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._entity, fieldNumber: 52)
      }
      if !_storage._relation.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._relation, fieldNumber: 53)
      }
      if let v = _storage._hasNumerizedTokensAnnotation_p {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 54)
      }
      if !_storage._mentions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._mentions, fieldNumber: 55)
      }
      if !_storage._mentionsForCoref.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._mentionsForCoref, fieldNumber: 56)
      }
      if let v = _storage._hasCorefMentionsAnnotation_p {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 57)
      }
      if let v = _storage._sentenceID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 58)
      }
      if let v = _storage._sectionDate {
        try visitor.visitSingularStringField(value: v, fieldNumber: 59)
      }
      if let v = _storage._sectionIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 60)
      }
      if let v = _storage._sectionName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 61)
      }
      if let v = _storage._sectionAuthor {
        try visitor.visitSingularStringField(value: v, fieldNumber: 62)
      }
      if let v = _storage._docID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 63)
      }
      if let v = _storage._sectionQuoted {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 64)
      }
      if let v = _storage._hasEntityMentionsAnnotation_p {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 65)
      }
      if let v = _storage._chapterIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 66)
      }
      if let v = _storage._paragraphIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 67)
      }
      if let v = _storage._hasKbptriplesAnnotation_p {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 68)
      }
      if let v = _storage._hasOpenieTriplesAnnotation_p {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 69)
      }
      if let v = _storage._enhancedSentence {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 70)
      }
      if let v = _storage._speaker {
        try visitor.visitSingularStringField(value: v, fieldNumber: 71)
      }
      if let v = _storage._speakerType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 72)
      }
      try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 100, end: 256)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_Sentence, rhs: Edu_Stanford_Nlp_Pipeline_Sentence) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._token != rhs_storage._token {return false}
        if _storage._tokenOffsetBegin != rhs_storage._tokenOffsetBegin {return false}
        if _storage._tokenOffsetEnd != rhs_storage._tokenOffsetEnd {return false}
        if _storage._sentenceIndex != rhs_storage._sentenceIndex {return false}
        if _storage._characterOffsetBegin != rhs_storage._characterOffsetBegin {return false}
        if _storage._characterOffsetEnd != rhs_storage._characterOffsetEnd {return false}
        if _storage._parseTree != rhs_storage._parseTree {return false}
        if _storage._binarizedParseTree != rhs_storage._binarizedParseTree {return false}
        if _storage._annotatedParseTree != rhs_storage._annotatedParseTree {return false}
        if _storage._sentiment != rhs_storage._sentiment {return false}
        if _storage._kBestParseTrees != rhs_storage._kBestParseTrees {return false}
        if _storage._basicDependencies != rhs_storage._basicDependencies {return false}
        if _storage._collapsedDependencies != rhs_storage._collapsedDependencies {return false}
        if _storage._collapsedCcprocessedDependencies != rhs_storage._collapsedCcprocessedDependencies {return false}
        if _storage._alternativeDependencies != rhs_storage._alternativeDependencies {return false}
        if _storage._openieTriple != rhs_storage._openieTriple {return false}
        if _storage._kbpTriple != rhs_storage._kbpTriple {return false}
        if _storage._entailedSentence != rhs_storage._entailedSentence {return false}
        if _storage._entailedClause != rhs_storage._entailedClause {return false}
        if _storage._enhancedDependencies != rhs_storage._enhancedDependencies {return false}
        if _storage._enhancedPlusPlusDependencies != rhs_storage._enhancedPlusPlusDependencies {return false}
        if _storage._character != rhs_storage._character {return false}
        if _storage._paragraph != rhs_storage._paragraph {return false}
        if _storage._text != rhs_storage._text {return false}
        if _storage._lineNumber != rhs_storage._lineNumber {return false}
        if _storage._hasRelationAnnotations_p != rhs_storage._hasRelationAnnotations_p {return false}
        if _storage._entity != rhs_storage._entity {return false}
        if _storage._relation != rhs_storage._relation {return false}
        if _storage._hasNumerizedTokensAnnotation_p != rhs_storage._hasNumerizedTokensAnnotation_p {return false}
        if _storage._mentions != rhs_storage._mentions {return false}
        if _storage._mentionsForCoref != rhs_storage._mentionsForCoref {return false}
        if _storage._hasCorefMentionsAnnotation_p != rhs_storage._hasCorefMentionsAnnotation_p {return false}
        if _storage._sentenceID != rhs_storage._sentenceID {return false}
        if _storage._sectionDate != rhs_storage._sectionDate {return false}
        if _storage._sectionIndex != rhs_storage._sectionIndex {return false}
        if _storage._sectionName != rhs_storage._sectionName {return false}
        if _storage._sectionAuthor != rhs_storage._sectionAuthor {return false}
        if _storage._docID != rhs_storage._docID {return false}
        if _storage._sectionQuoted != rhs_storage._sectionQuoted {return false}
        if _storage._hasEntityMentionsAnnotation_p != rhs_storage._hasEntityMentionsAnnotation_p {return false}
        if _storage._hasKbptriplesAnnotation_p != rhs_storage._hasKbptriplesAnnotation_p {return false}
        if _storage._hasOpenieTriplesAnnotation_p != rhs_storage._hasOpenieTriplesAnnotation_p {return false}
        if _storage._chapterIndex != rhs_storage._chapterIndex {return false}
        if _storage._paragraphIndex != rhs_storage._paragraphIndex {return false}
        if _storage._enhancedSentence != rhs_storage._enhancedSentence {return false}
        if _storage._speaker != rhs_storage._speaker {return false}
        if _storage._speakerType != rhs_storage._speakerType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension Edu_Stanford_Nlp_Pipeline_Token: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Token"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "word"),
    2: .same(proto: "pos"),
    3: .same(proto: "value"),
    4: .same(proto: "category"),
    5: .same(proto: "before"),
    6: .same(proto: "after"),
    7: .same(proto: "originalText"),
    8: .same(proto: "ner"),
    62: .same(proto: "coarseNER"),
    63: .same(proto: "fineGrainedNER"),
    66: .same(proto: "nerLabelProbs"),
    9: .same(proto: "normalizedNER"),
    10: .same(proto: "lemma"),
    11: .same(proto: "beginChar"),
    12: .same(proto: "endChar"),
    13: .same(proto: "utterance"),
    14: .same(proto: "speaker"),
    77: .same(proto: "speakerType"),
    15: .same(proto: "beginIndex"),
    16: .same(proto: "endIndex"),
    17: .same(proto: "tokenBeginIndex"),
    18: .same(proto: "tokenEndIndex"),
    19: .same(proto: "timexValue"),
    21: .same(proto: "hasXmlContext"),
    22: .same(proto: "xmlContext"),
    23: .same(proto: "corefClusterID"),
    24: .same(proto: "answer"),
    26: .same(proto: "headWordIndex"),
    27: .same(proto: "operator"),
    28: .same(proto: "polarity"),
    39: .standard(proto: "polarity_dir"),
    29: .same(proto: "span"),
    30: .same(proto: "sentiment"),
    31: .same(proto: "quotationIndex"),
    32: .same(proto: "conllUFeatures"),
    33: .same(proto: "coarseTag"),
    34: .same(proto: "conllUTokenSpan"),
    35: .same(proto: "conllUMisc"),
    36: .same(proto: "conllUSecondaryDeps"),
    37: .same(proto: "wikipediaEntity"),
    38: .same(proto: "isNewline"),
    51: .same(proto: "gender"),
    52: .same(proto: "trueCase"),
    53: .same(proto: "trueCaseText"),
    54: .same(proto: "chineseChar"),
    55: .same(proto: "chineseSeg"),
    60: .same(proto: "chineseXMLChar"),
    76: .same(proto: "arabicSeg"),
    56: .same(proto: "sectionName"),
    57: .same(proto: "sectionAuthor"),
    58: .same(proto: "sectionDate"),
    59: .same(proto: "sectionEndLabel"),
    61: .same(proto: "parent"),
    64: .same(proto: "corefMentionIndex"),
    65: .same(proto: "entityMentionIndex"),
    67: .same(proto: "isMWT"),
    68: .same(proto: "isFirstMWT"),
    69: .same(proto: "mwtText"),
    70: .same(proto: "numericValue"),
    71: .same(proto: "numericType"),
    72: .same(proto: "numericCompositeValue"),
    73: .same(proto: "numericCompositeType"),
    74: .same(proto: "codepointOffsetBegin"),
    75: .same(proto: "codepointOffsetEnd"),
  ]

  fileprivate class _StorageClass {
    var _word: String? = nil
    var _pos: String? = nil
    var _value: String? = nil
    var _category: String? = nil
    var _before: String? = nil
    var _after: String? = nil
    var _originalText: String? = nil
    var _ner: String? = nil
    var _coarseNer: String? = nil
    var _fineGrainedNer: String? = nil
    var _nerLabelProbs: [String] = []
    var _normalizedNer: String? = nil
    var _lemma: String? = nil
    var _beginChar: UInt32? = nil
    var _endChar: UInt32? = nil
    var _utterance: UInt32? = nil
    var _speaker: String? = nil
    var _speakerType: String? = nil
    var _beginIndex: UInt32? = nil
    var _endIndex: UInt32? = nil
    var _tokenBeginIndex: UInt32? = nil
    var _tokenEndIndex: UInt32? = nil
    var _timexValue: Edu_Stanford_Nlp_Pipeline_Timex? = nil
    var _hasXmlContext_p: Bool? = nil
    var _xmlContext: [String] = []
    var _corefClusterID: UInt32? = nil
    var _answer: String? = nil
    var _headWordIndex: UInt32? = nil
    var _operator: Edu_Stanford_Nlp_Pipeline_Operator? = nil
    var _polarity: Edu_Stanford_Nlp_Pipeline_Polarity? = nil
    var _polarityDir: String? = nil
    var _span: Edu_Stanford_Nlp_Pipeline_Span? = nil
    var _sentiment: String? = nil
    var _quotationIndex: Int32? = nil
    var _conllUfeatures: Edu_Stanford_Nlp_Pipeline_MapStringString? = nil
    var _coarseTag: String? = nil
    var _conllUtokenSpan: Edu_Stanford_Nlp_Pipeline_Span? = nil
    var _conllUmisc: String? = nil
    var _conllUsecondaryDeps: Edu_Stanford_Nlp_Pipeline_MapStringString? = nil
    var _wikipediaEntity: String? = nil
    var _isNewline: Bool? = nil
    var _gender: String? = nil
    var _trueCase: String? = nil
    var _trueCaseText: String? = nil
    var _chineseChar: String? = nil
    var _chineseSeg: String? = nil
    var _chineseXmlchar: String? = nil
    var _arabicSeg: String? = nil
    var _sectionName: String? = nil
    var _sectionAuthor: String? = nil
    var _sectionDate: String? = nil
    var _sectionEndLabel: String? = nil
    var _parent: String? = nil
    var _corefMentionIndex: [UInt32] = []
    var _entityMentionIndex: UInt32? = nil
    var _isMwt: Bool? = nil
    var _isFirstMwt: Bool? = nil
    var _mwtText: String? = nil
    var _numericValue: UInt64? = nil
    var _numericType: String? = nil
    var _numericCompositeValue: UInt64? = nil
    var _numericCompositeType: String? = nil
    var _codepointOffsetBegin: UInt32? = nil
    var _codepointOffsetEnd: UInt32? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _word = source._word
      _pos = source._pos
      _value = source._value
      _category = source._category
      _before = source._before
      _after = source._after
      _originalText = source._originalText
      _ner = source._ner
      _coarseNer = source._coarseNer
      _fineGrainedNer = source._fineGrainedNer
      _nerLabelProbs = source._nerLabelProbs
      _normalizedNer = source._normalizedNer
      _lemma = source._lemma
      _beginChar = source._beginChar
      _endChar = source._endChar
      _utterance = source._utterance
      _speaker = source._speaker
      _speakerType = source._speakerType
      _beginIndex = source._beginIndex
      _endIndex = source._endIndex
      _tokenBeginIndex = source._tokenBeginIndex
      _tokenEndIndex = source._tokenEndIndex
      _timexValue = source._timexValue
      _hasXmlContext_p = source._hasXmlContext_p
      _xmlContext = source._xmlContext
      _corefClusterID = source._corefClusterID
      _answer = source._answer
      _headWordIndex = source._headWordIndex
      _operator = source._operator
      _polarity = source._polarity
      _polarityDir = source._polarityDir
      _span = source._span
      _sentiment = source._sentiment
      _quotationIndex = source._quotationIndex
      _conllUfeatures = source._conllUfeatures
      _coarseTag = source._coarseTag
      _conllUtokenSpan = source._conllUtokenSpan
      _conllUmisc = source._conllUmisc
      _conllUsecondaryDeps = source._conllUsecondaryDeps
      _wikipediaEntity = source._wikipediaEntity
      _isNewline = source._isNewline
      _gender = source._gender
      _trueCase = source._trueCase
      _trueCaseText = source._trueCaseText
      _chineseChar = source._chineseChar
      _chineseSeg = source._chineseSeg
      _chineseXmlchar = source._chineseXmlchar
      _arabicSeg = source._arabicSeg
      _sectionName = source._sectionName
      _sectionAuthor = source._sectionAuthor
      _sectionDate = source._sectionDate
      _sectionEndLabel = source._sectionEndLabel
      _parent = source._parent
      _corefMentionIndex = source._corefMentionIndex
      _entityMentionIndex = source._entityMentionIndex
      _isMwt = source._isMwt
      _isFirstMwt = source._isFirstMwt
      _mwtText = source._mwtText
      _numericValue = source._numericValue
      _numericType = source._numericType
      _numericCompositeValue = source._numericCompositeValue
      _numericCompositeType = source._numericCompositeType
      _codepointOffsetBegin = source._codepointOffsetBegin
      _codepointOffsetEnd = source._codepointOffsetEnd
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._operator, !v.isInitialized {return false}
      if let v = _storage._polarity, !v.isInitialized {return false}
      if let v = _storage._span, !v.isInitialized {return false}
      if let v = _storage._conllUtokenSpan, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._word) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._pos) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._value) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._category) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._before) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._after) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._originalText) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._ner) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._normalizedNer) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._lemma) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._beginChar) }()
        case 12: try { try decoder.decodeSingularUInt32Field(value: &_storage._endChar) }()
        case 13: try { try decoder.decodeSingularUInt32Field(value: &_storage._utterance) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._speaker) }()
        case 15: try { try decoder.decodeSingularUInt32Field(value: &_storage._beginIndex) }()
        case 16: try { try decoder.decodeSingularUInt32Field(value: &_storage._endIndex) }()
        case 17: try { try decoder.decodeSingularUInt32Field(value: &_storage._tokenBeginIndex) }()
        case 18: try { try decoder.decodeSingularUInt32Field(value: &_storage._tokenEndIndex) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._timexValue) }()
        case 21: try { try decoder.decodeSingularBoolField(value: &_storage._hasXmlContext_p) }()
        case 22: try { try decoder.decodeRepeatedStringField(value: &_storage._xmlContext) }()
        case 23: try { try decoder.decodeSingularUInt32Field(value: &_storage._corefClusterID) }()
        case 24: try { try decoder.decodeSingularStringField(value: &_storage._answer) }()
        case 26: try { try decoder.decodeSingularUInt32Field(value: &_storage._headWordIndex) }()
        case 27: try { try decoder.decodeSingularMessageField(value: &_storage._operator) }()
        case 28: try { try decoder.decodeSingularMessageField(value: &_storage._polarity) }()
        case 29: try { try decoder.decodeSingularMessageField(value: &_storage._span) }()
        case 30: try { try decoder.decodeSingularStringField(value: &_storage._sentiment) }()
        case 31: try { try decoder.decodeSingularInt32Field(value: &_storage._quotationIndex) }()
        case 32: try { try decoder.decodeSingularMessageField(value: &_storage._conllUfeatures) }()
        case 33: try { try decoder.decodeSingularStringField(value: &_storage._coarseTag) }()
        case 34: try { try decoder.decodeSingularMessageField(value: &_storage._conllUtokenSpan) }()
        case 35: try { try decoder.decodeSingularStringField(value: &_storage._conllUmisc) }()
        case 36: try { try decoder.decodeSingularMessageField(value: &_storage._conllUsecondaryDeps) }()
        case 37: try { try decoder.decodeSingularStringField(value: &_storage._wikipediaEntity) }()
        case 38: try { try decoder.decodeSingularBoolField(value: &_storage._isNewline) }()
        case 39: try { try decoder.decodeSingularStringField(value: &_storage._polarityDir) }()
        case 51: try { try decoder.decodeSingularStringField(value: &_storage._gender) }()
        case 52: try { try decoder.decodeSingularStringField(value: &_storage._trueCase) }()
        case 53: try { try decoder.decodeSingularStringField(value: &_storage._trueCaseText) }()
        case 54: try { try decoder.decodeSingularStringField(value: &_storage._chineseChar) }()
        case 55: try { try decoder.decodeSingularStringField(value: &_storage._chineseSeg) }()
        case 56: try { try decoder.decodeSingularStringField(value: &_storage._sectionName) }()
        case 57: try { try decoder.decodeSingularStringField(value: &_storage._sectionAuthor) }()
        case 58: try { try decoder.decodeSingularStringField(value: &_storage._sectionDate) }()
        case 59: try { try decoder.decodeSingularStringField(value: &_storage._sectionEndLabel) }()
        case 60: try { try decoder.decodeSingularStringField(value: &_storage._chineseXmlchar) }()
        case 61: try { try decoder.decodeSingularStringField(value: &_storage._parent) }()
        case 62: try { try decoder.decodeSingularStringField(value: &_storage._coarseNer) }()
        case 63: try { try decoder.decodeSingularStringField(value: &_storage._fineGrainedNer) }()
        case 64: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._corefMentionIndex) }()
        case 65: try { try decoder.decodeSingularUInt32Field(value: &_storage._entityMentionIndex) }()
        case 66: try { try decoder.decodeRepeatedStringField(value: &_storage._nerLabelProbs) }()
        case 67: try { try decoder.decodeSingularBoolField(value: &_storage._isMwt) }()
        case 68: try { try decoder.decodeSingularBoolField(value: &_storage._isFirstMwt) }()
        case 69: try { try decoder.decodeSingularStringField(value: &_storage._mwtText) }()
        case 70: try { try decoder.decodeSingularUInt64Field(value: &_storage._numericValue) }()
        case 71: try { try decoder.decodeSingularStringField(value: &_storage._numericType) }()
        case 72: try { try decoder.decodeSingularUInt64Field(value: &_storage._numericCompositeValue) }()
        case 73: try { try decoder.decodeSingularStringField(value: &_storage._numericCompositeType) }()
        case 74: try { try decoder.decodeSingularUInt32Field(value: &_storage._codepointOffsetBegin) }()
        case 75: try { try decoder.decodeSingularUInt32Field(value: &_storage._codepointOffsetEnd) }()
        case 76: try { try decoder.decodeSingularStringField(value: &_storage._arabicSeg) }()
        case 77: try { try decoder.decodeSingularStringField(value: &_storage._speakerType) }()
        case 100..<256:
          try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: Edu_Stanford_Nlp_Pipeline_Token.self, fieldNumber: fieldNumber) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._word {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._pos {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._value {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if let v = _storage._category {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
      if let v = _storage._before {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      }
      if let v = _storage._after {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      }
      if let v = _storage._originalText {
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      }
      if let v = _storage._ner {
        try visitor.visitSingularStringField(value: v, fieldNumber: 8)
      }
      if let v = _storage._normalizedNer {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      }
      if let v = _storage._lemma {
        try visitor.visitSingularStringField(value: v, fieldNumber: 10)
      }
      if let v = _storage._beginChar {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 11)
      }
      if let v = _storage._endChar {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 12)
      }
      if let v = _storage._utterance {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 13)
      }
      if let v = _storage._speaker {
        try visitor.visitSingularStringField(value: v, fieldNumber: 14)
      }
      if let v = _storage._beginIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 15)
      }
      if let v = _storage._endIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 16)
      }
      if let v = _storage._tokenBeginIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 17)
      }
      if let v = _storage._tokenEndIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 18)
      }
      if let v = _storage._timexValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }
      if let v = _storage._hasXmlContext_p {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 21)
      }
      if !_storage._xmlContext.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._xmlContext, fieldNumber: 22)
      }
      if let v = _storage._corefClusterID {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 23)
      }
      if let v = _storage._answer {
        try visitor.visitSingularStringField(value: v, fieldNumber: 24)
      }
      if let v = _storage._headWordIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 26)
      }
      if let v = _storage._operator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      }
      if let v = _storage._polarity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      }
      if let v = _storage._span {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      }
      if let v = _storage._sentiment {
        try visitor.visitSingularStringField(value: v, fieldNumber: 30)
      }
      if let v = _storage._quotationIndex {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 31)
      }
      if let v = _storage._conllUfeatures {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      }
      if let v = _storage._coarseTag {
        try visitor.visitSingularStringField(value: v, fieldNumber: 33)
      }
      if let v = _storage._conllUtokenSpan {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      }
      if let v = _storage._conllUmisc {
        try visitor.visitSingularStringField(value: v, fieldNumber: 35)
      }
      if let v = _storage._conllUsecondaryDeps {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
      }
      if let v = _storage._wikipediaEntity {
        try visitor.visitSingularStringField(value: v, fieldNumber: 37)
      }
      if let v = _storage._isNewline {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 38)
      }
      if let v = _storage._polarityDir {
        try visitor.visitSingularStringField(value: v, fieldNumber: 39)
      }
      if let v = _storage._gender {
        try visitor.visitSingularStringField(value: v, fieldNumber: 51)
      }
      if let v = _storage._trueCase {
        try visitor.visitSingularStringField(value: v, fieldNumber: 52)
      }
      if let v = _storage._trueCaseText {
        try visitor.visitSingularStringField(value: v, fieldNumber: 53)
      }
      if let v = _storage._chineseChar {
        try visitor.visitSingularStringField(value: v, fieldNumber: 54)
      }
      if let v = _storage._chineseSeg {
        try visitor.visitSingularStringField(value: v, fieldNumber: 55)
      }
      if let v = _storage._sectionName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 56)
      }
      if let v = _storage._sectionAuthor {
        try visitor.visitSingularStringField(value: v, fieldNumber: 57)
      }
      if let v = _storage._sectionDate {
        try visitor.visitSingularStringField(value: v, fieldNumber: 58)
      }
      if let v = _storage._sectionEndLabel {
        try visitor.visitSingularStringField(value: v, fieldNumber: 59)
      }
      if let v = _storage._chineseXmlchar {
        try visitor.visitSingularStringField(value: v, fieldNumber: 60)
      }
      if let v = _storage._parent {
        try visitor.visitSingularStringField(value: v, fieldNumber: 61)
      }
      if let v = _storage._coarseNer {
        try visitor.visitSingularStringField(value: v, fieldNumber: 62)
      }
      if let v = _storage._fineGrainedNer {
        try visitor.visitSingularStringField(value: v, fieldNumber: 63)
      }
      if !_storage._corefMentionIndex.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._corefMentionIndex, fieldNumber: 64)
      }
      if let v = _storage._entityMentionIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 65)
      }
      if !_storage._nerLabelProbs.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._nerLabelProbs, fieldNumber: 66)
      }
      if let v = _storage._isMwt {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 67)
      }
      if let v = _storage._isFirstMwt {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 68)
      }
      if let v = _storage._mwtText {
        try visitor.visitSingularStringField(value: v, fieldNumber: 69)
      }
      if let v = _storage._numericValue {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 70)
      }
      if let v = _storage._numericType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 71)
      }
      if let v = _storage._numericCompositeValue {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 72)
      }
      if let v = _storage._numericCompositeType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 73)
      }
      if let v = _storage._codepointOffsetBegin {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 74)
      }
      if let v = _storage._codepointOffsetEnd {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 75)
      }
      if let v = _storage._arabicSeg {
        try visitor.visitSingularStringField(value: v, fieldNumber: 76)
      }
      if let v = _storage._speakerType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 77)
      }
      try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 100, end: 256)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_Token, rhs: Edu_Stanford_Nlp_Pipeline_Token) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._word != rhs_storage._word {return false}
        if _storage._pos != rhs_storage._pos {return false}
        if _storage._value != rhs_storage._value {return false}
        if _storage._category != rhs_storage._category {return false}
        if _storage._before != rhs_storage._before {return false}
        if _storage._after != rhs_storage._after {return false}
        if _storage._originalText != rhs_storage._originalText {return false}
        if _storage._ner != rhs_storage._ner {return false}
        if _storage._coarseNer != rhs_storage._coarseNer {return false}
        if _storage._fineGrainedNer != rhs_storage._fineGrainedNer {return false}
        if _storage._nerLabelProbs != rhs_storage._nerLabelProbs {return false}
        if _storage._normalizedNer != rhs_storage._normalizedNer {return false}
        if _storage._lemma != rhs_storage._lemma {return false}
        if _storage._beginChar != rhs_storage._beginChar {return false}
        if _storage._endChar != rhs_storage._endChar {return false}
        if _storage._utterance != rhs_storage._utterance {return false}
        if _storage._speaker != rhs_storage._speaker {return false}
        if _storage._speakerType != rhs_storage._speakerType {return false}
        if _storage._beginIndex != rhs_storage._beginIndex {return false}
        if _storage._endIndex != rhs_storage._endIndex {return false}
        if _storage._tokenBeginIndex != rhs_storage._tokenBeginIndex {return false}
        if _storage._tokenEndIndex != rhs_storage._tokenEndIndex {return false}
        if _storage._timexValue != rhs_storage._timexValue {return false}
        if _storage._hasXmlContext_p != rhs_storage._hasXmlContext_p {return false}
        if _storage._xmlContext != rhs_storage._xmlContext {return false}
        if _storage._corefClusterID != rhs_storage._corefClusterID {return false}
        if _storage._answer != rhs_storage._answer {return false}
        if _storage._headWordIndex != rhs_storage._headWordIndex {return false}
        if _storage._operator != rhs_storage._operator {return false}
        if _storage._polarity != rhs_storage._polarity {return false}
        if _storage._polarityDir != rhs_storage._polarityDir {return false}
        if _storage._span != rhs_storage._span {return false}
        if _storage._sentiment != rhs_storage._sentiment {return false}
        if _storage._quotationIndex != rhs_storage._quotationIndex {return false}
        if _storage._conllUfeatures != rhs_storage._conllUfeatures {return false}
        if _storage._coarseTag != rhs_storage._coarseTag {return false}
        if _storage._conllUtokenSpan != rhs_storage._conllUtokenSpan {return false}
        if _storage._conllUmisc != rhs_storage._conllUmisc {return false}
        if _storage._conllUsecondaryDeps != rhs_storage._conllUsecondaryDeps {return false}
        if _storage._wikipediaEntity != rhs_storage._wikipediaEntity {return false}
        if _storage._isNewline != rhs_storage._isNewline {return false}
        if _storage._gender != rhs_storage._gender {return false}
        if _storage._trueCase != rhs_storage._trueCase {return false}
        if _storage._trueCaseText != rhs_storage._trueCaseText {return false}
        if _storage._chineseChar != rhs_storage._chineseChar {return false}
        if _storage._chineseSeg != rhs_storage._chineseSeg {return false}
        if _storage._chineseXmlchar != rhs_storage._chineseXmlchar {return false}
        if _storage._arabicSeg != rhs_storage._arabicSeg {return false}
        if _storage._sectionName != rhs_storage._sectionName {return false}
        if _storage._sectionAuthor != rhs_storage._sectionAuthor {return false}
        if _storage._sectionDate != rhs_storage._sectionDate {return false}
        if _storage._sectionEndLabel != rhs_storage._sectionEndLabel {return false}
        if _storage._parent != rhs_storage._parent {return false}
        if _storage._corefMentionIndex != rhs_storage._corefMentionIndex {return false}
        if _storage._entityMentionIndex != rhs_storage._entityMentionIndex {return false}
        if _storage._isMwt != rhs_storage._isMwt {return false}
        if _storage._isFirstMwt != rhs_storage._isFirstMwt {return false}
        if _storage._mwtText != rhs_storage._mwtText {return false}
        if _storage._numericValue != rhs_storage._numericValue {return false}
        if _storage._numericType != rhs_storage._numericType {return false}
        if _storage._numericCompositeValue != rhs_storage._numericCompositeValue {return false}
        if _storage._numericCompositeType != rhs_storage._numericCompositeType {return false}
        if _storage._codepointOffsetBegin != rhs_storage._codepointOffsetBegin {return false}
        if _storage._codepointOffsetEnd != rhs_storage._codepointOffsetEnd {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension Edu_Stanford_Nlp_Pipeline_Quote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Quote"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "begin"),
    3: .same(proto: "end"),
    5: .same(proto: "sentenceBegin"),
    6: .same(proto: "sentenceEnd"),
    7: .same(proto: "tokenBegin"),
    8: .same(proto: "tokenEnd"),
    9: .same(proto: "docid"),
    10: .same(proto: "index"),
    11: .same(proto: "author"),
    12: .same(proto: "mention"),
    13: .same(proto: "mentionBegin"),
    14: .same(proto: "mentionEnd"),
    15: .same(proto: "mentionType"),
    16: .same(proto: "mentionSieve"),
    17: .same(proto: "speaker"),
    18: .same(proto: "speakerSieve"),
    19: .same(proto: "canonicalMention"),
    20: .same(proto: "canonicalMentionBegin"),
    21: .same(proto: "canonicalMentionEnd"),
    22: .same(proto: "attributionDependencyGraph"),
  ]

  fileprivate class _StorageClass {
    var _text: String? = nil
    var _begin: UInt32? = nil
    var _end: UInt32? = nil
    var _sentenceBegin: UInt32? = nil
    var _sentenceEnd: UInt32? = nil
    var _tokenBegin: UInt32? = nil
    var _tokenEnd: UInt32? = nil
    var _docid: String? = nil
    var _index: UInt32? = nil
    var _author: String? = nil
    var _mention: String? = nil
    var _mentionBegin: UInt32? = nil
    var _mentionEnd: UInt32? = nil
    var _mentionType: String? = nil
    var _mentionSieve: String? = nil
    var _speaker: String? = nil
    var _speakerSieve: String? = nil
    var _canonicalMention: String? = nil
    var _canonicalMentionBegin: UInt32? = nil
    var _canonicalMentionEnd: UInt32? = nil
    var _attributionDependencyGraph: Edu_Stanford_Nlp_Pipeline_DependencyGraph? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _text = source._text
      _begin = source._begin
      _end = source._end
      _sentenceBegin = source._sentenceBegin
      _sentenceEnd = source._sentenceEnd
      _tokenBegin = source._tokenBegin
      _tokenEnd = source._tokenEnd
      _docid = source._docid
      _index = source._index
      _author = source._author
      _mention = source._mention
      _mentionBegin = source._mentionBegin
      _mentionEnd = source._mentionEnd
      _mentionType = source._mentionType
      _mentionSieve = source._mentionSieve
      _speaker = source._speaker
      _speakerSieve = source._speakerSieve
      _canonicalMention = source._canonicalMention
      _canonicalMentionBegin = source._canonicalMentionBegin
      _canonicalMentionEnd = source._canonicalMentionEnd
      _attributionDependencyGraph = source._attributionDependencyGraph
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._attributionDependencyGraph, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._text) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._begin) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._end) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._sentenceBegin) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._sentenceEnd) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._tokenBegin) }()
        case 8: try { try decoder.decodeSingularUInt32Field(value: &_storage._tokenEnd) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._docid) }()
        case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._index) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._author) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._mention) }()
        case 13: try { try decoder.decodeSingularUInt32Field(value: &_storage._mentionBegin) }()
        case 14: try { try decoder.decodeSingularUInt32Field(value: &_storage._mentionEnd) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._mentionType) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._mentionSieve) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._speaker) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._speakerSieve) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._canonicalMention) }()
        case 20: try { try decoder.decodeSingularUInt32Field(value: &_storage._canonicalMentionBegin) }()
        case 21: try { try decoder.decodeSingularUInt32Field(value: &_storage._canonicalMentionEnd) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._attributionDependencyGraph) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._text {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._begin {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
      }
      if let v = _storage._end {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
      }
      if let v = _storage._sentenceBegin {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
      }
      if let v = _storage._sentenceEnd {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
      }
      if let v = _storage._tokenBegin {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
      }
      if let v = _storage._tokenEnd {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
      }
      if let v = _storage._docid {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      }
      if let v = _storage._index {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
      }
      if let v = _storage._author {
        try visitor.visitSingularStringField(value: v, fieldNumber: 11)
      }
      if let v = _storage._mention {
        try visitor.visitSingularStringField(value: v, fieldNumber: 12)
      }
      if let v = _storage._mentionBegin {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 13)
      }
      if let v = _storage._mentionEnd {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 14)
      }
      if let v = _storage._mentionType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 15)
      }
      if let v = _storage._mentionSieve {
        try visitor.visitSingularStringField(value: v, fieldNumber: 16)
      }
      if let v = _storage._speaker {
        try visitor.visitSingularStringField(value: v, fieldNumber: 17)
      }
      if let v = _storage._speakerSieve {
        try visitor.visitSingularStringField(value: v, fieldNumber: 18)
      }
      if let v = _storage._canonicalMention {
        try visitor.visitSingularStringField(value: v, fieldNumber: 19)
      }
      if let v = _storage._canonicalMentionBegin {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 20)
      }
      if let v = _storage._canonicalMentionEnd {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 21)
      }
      if let v = _storage._attributionDependencyGraph {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_Quote, rhs: Edu_Stanford_Nlp_Pipeline_Quote) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._text != rhs_storage._text {return false}
        if _storage._begin != rhs_storage._begin {return false}
        if _storage._end != rhs_storage._end {return false}
        if _storage._sentenceBegin != rhs_storage._sentenceBegin {return false}
        if _storage._sentenceEnd != rhs_storage._sentenceEnd {return false}
        if _storage._tokenBegin != rhs_storage._tokenBegin {return false}
        if _storage._tokenEnd != rhs_storage._tokenEnd {return false}
        if _storage._docid != rhs_storage._docid {return false}
        if _storage._index != rhs_storage._index {return false}
        if _storage._author != rhs_storage._author {return false}
        if _storage._mention != rhs_storage._mention {return false}
        if _storage._mentionBegin != rhs_storage._mentionBegin {return false}
        if _storage._mentionEnd != rhs_storage._mentionEnd {return false}
        if _storage._mentionType != rhs_storage._mentionType {return false}
        if _storage._mentionSieve != rhs_storage._mentionSieve {return false}
        if _storage._speaker != rhs_storage._speaker {return false}
        if _storage._speakerSieve != rhs_storage._speakerSieve {return false}
        if _storage._canonicalMention != rhs_storage._canonicalMention {return false}
        if _storage._canonicalMentionBegin != rhs_storage._canonicalMentionBegin {return false}
        if _storage._canonicalMentionEnd != rhs_storage._canonicalMentionEnd {return false}
        if _storage._attributionDependencyGraph != rhs_storage._attributionDependencyGraph {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Edu_Stanford_Nlp_Pipeline_ParseTree: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ParseTree"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "child"),
    2: .same(proto: "value"),
    3: .same(proto: "yieldBeginIndex"),
    4: .same(proto: "yieldEndIndex"),
    5: .same(proto: "score"),
    6: .same(proto: "sentiment"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.child) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._value) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._yieldBeginIndex) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._yieldEndIndex) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self._score) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self._sentiment) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.child.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.child, fieldNumber: 1)
    }
    if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._yieldBeginIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._yieldEndIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._score {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 5)
    }
    if let v = self._sentiment {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_ParseTree, rhs: Edu_Stanford_Nlp_Pipeline_ParseTree) -> Bool {
    if lhs.child != rhs.child {return false}
    if lhs._value != rhs._value {return false}
    if lhs._yieldBeginIndex != rhs._yieldBeginIndex {return false}
    if lhs._yieldEndIndex != rhs._yieldEndIndex {return false}
    if lhs._score != rhs._score {return false}
    if lhs._sentiment != rhs._sentiment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Edu_Stanford_Nlp_Pipeline_DependencyGraph: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DependencyGraph"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "node"),
    2: .same(proto: "edge"),
    3: .same(proto: "root"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.node) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.edge) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.node) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.edge) }()
      case 3: try { try decoder.decodeRepeatedUInt32Field(value: &self.root) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.node.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.node, fieldNumber: 1)
    }
    if !self.edge.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.edge, fieldNumber: 2)
    }
    if !self.root.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.root, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_DependencyGraph, rhs: Edu_Stanford_Nlp_Pipeline_DependencyGraph) -> Bool {
    if lhs.node != rhs.node {return false}
    if lhs.edge != rhs.edge {return false}
    if lhs.root != rhs.root {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Edu_Stanford_Nlp_Pipeline_DependencyGraph.Node: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Edu_Stanford_Nlp_Pipeline_DependencyGraph.protoMessageName + ".Node"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sentenceIndex"),
    2: .same(proto: "index"),
    3: .same(proto: "copyAnnotation"),
  ]

  public var isInitialized: Bool {
    if self._sentenceIndex == nil {return false}
    if self._index == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._sentenceIndex) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._index) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._copyAnnotation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._sentenceIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._index {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._copyAnnotation {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_DependencyGraph.Node, rhs: Edu_Stanford_Nlp_Pipeline_DependencyGraph.Node) -> Bool {
    if lhs._sentenceIndex != rhs._sentenceIndex {return false}
    if lhs._index != rhs._index {return false}
    if lhs._copyAnnotation != rhs._copyAnnotation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Edu_Stanford_Nlp_Pipeline_DependencyGraph.Edge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Edu_Stanford_Nlp_Pipeline_DependencyGraph.protoMessageName + ".Edge"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .same(proto: "target"),
    3: .same(proto: "dep"),
    4: .same(proto: "isExtra"),
    5: .same(proto: "sourceCopy"),
    6: .same(proto: "targetCopy"),
    7: .same(proto: "language"),
  ]

  public var isInitialized: Bool {
    if self._source == nil {return false}
    if self._target == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._source) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._target) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._dep) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._isExtra) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._sourceCopy) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._targetCopy) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self._language) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._source {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._target {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._dep {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._isExtra {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }
    if let v = self._sourceCopy {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    if let v = self._targetCopy {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    }
    if let v = self._language {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_DependencyGraph.Edge, rhs: Edu_Stanford_Nlp_Pipeline_DependencyGraph.Edge) -> Bool {
    if lhs._source != rhs._source {return false}
    if lhs._target != rhs._target {return false}
    if lhs._dep != rhs._dep {return false}
    if lhs._isExtra != rhs._isExtra {return false}
    if lhs._sourceCopy != rhs._sourceCopy {return false}
    if lhs._targetCopy != rhs._targetCopy {return false}
    if lhs._language != rhs._language {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Edu_Stanford_Nlp_Pipeline_CorefChain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CorefChain"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chainID"),
    2: .same(proto: "mention"),
    3: .same(proto: "representative"),
  ]

  public var isInitialized: Bool {
    if self._chainID == nil {return false}
    if self._representative == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._chainID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.mention) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._representative) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._chainID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if !self.mention.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mention, fieldNumber: 2)
    }
    if let v = self._representative {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_CorefChain, rhs: Edu_Stanford_Nlp_Pipeline_CorefChain) -> Bool {
    if lhs._chainID != rhs._chainID {return false}
    if lhs.mention != rhs.mention {return false}
    if lhs._representative != rhs._representative {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Edu_Stanford_Nlp_Pipeline_CorefChain.CorefMention: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Edu_Stanford_Nlp_Pipeline_CorefChain.protoMessageName + ".CorefMention"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mentionID"),
    2: .same(proto: "mentionType"),
    3: .same(proto: "number"),
    4: .same(proto: "gender"),
    5: .same(proto: "animacy"),
    6: .same(proto: "beginIndex"),
    7: .same(proto: "endIndex"),
    9: .same(proto: "headIndex"),
    10: .same(proto: "sentenceIndex"),
    11: .same(proto: "position"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._mentionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._mentionType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._number) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._gender) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._animacy) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._beginIndex) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._endIndex) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self._headIndex) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self._sentenceIndex) }()
      case 11: try { try decoder.decodeSingularUInt32Field(value: &self._position) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mentionID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._mentionType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._number {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._gender {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._animacy {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    if let v = self._beginIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    }
    if let v = self._endIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    }
    if let v = self._headIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
    }
    if let v = self._sentenceIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
    }
    if let v = self._position {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_CorefChain.CorefMention, rhs: Edu_Stanford_Nlp_Pipeline_CorefChain.CorefMention) -> Bool {
    if lhs._mentionID != rhs._mentionID {return false}
    if lhs._mentionType != rhs._mentionType {return false}
    if lhs._number != rhs._number {return false}
    if lhs._gender != rhs._gender {return false}
    if lhs._animacy != rhs._animacy {return false}
    if lhs._beginIndex != rhs._beginIndex {return false}
    if lhs._endIndex != rhs._endIndex {return false}
    if lhs._headIndex != rhs._headIndex {return false}
    if lhs._sentenceIndex != rhs._sentenceIndex {return false}
    if lhs._position != rhs._position {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Edu_Stanford_Nlp_Pipeline_Mention: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Mention"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mentionID"),
    2: .same(proto: "mentionType"),
    3: .same(proto: "number"),
    4: .same(proto: "gender"),
    5: .same(proto: "animacy"),
    6: .same(proto: "person"),
    7: .same(proto: "startIndex"),
    9: .same(proto: "endIndex"),
    10: .same(proto: "headIndex"),
    11: .same(proto: "headString"),
    12: .same(proto: "nerString"),
    13: .same(proto: "originalRef"),
    14: .same(proto: "goldCorefClusterID"),
    15: .same(proto: "corefClusterID"),
    16: .same(proto: "mentionNum"),
    17: .same(proto: "sentNum"),
    18: .same(proto: "utter"),
    19: .same(proto: "paragraph"),
    20: .same(proto: "isSubject"),
    21: .same(proto: "isDirectObject"),
    22: .same(proto: "isIndirectObject"),
    23: .same(proto: "isPrepositionObject"),
    24: .same(proto: "hasTwin"),
    25: .same(proto: "generic"),
    26: .same(proto: "isSingleton"),
    27: .same(proto: "hasBasicDependency"),
    28: .same(proto: "hasEnhancedDepenedncy"),
    29: .same(proto: "hasContextParseTree"),
    30: .same(proto: "headIndexedWord"),
    31: .same(proto: "dependingVerb"),
    32: .same(proto: "headWord"),
    33: .same(proto: "speakerInfo"),
    50: .same(proto: "sentenceWords"),
    51: .same(proto: "originalSpan"),
    52: .same(proto: "dependents"),
    53: .same(proto: "preprocessedTerms"),
    54: .same(proto: "appositions"),
    55: .same(proto: "predicateNominatives"),
    56: .same(proto: "relativePronouns"),
    57: .same(proto: "listMembers"),
    58: .same(proto: "belongToLists"),
  ]

  fileprivate class _StorageClass {
    var _mentionID: Int32? = nil
    var _mentionType: String? = nil
    var _number: String? = nil
    var _gender: String? = nil
    var _animacy: String? = nil
    var _person: String? = nil
    var _startIndex: UInt32? = nil
    var _endIndex: UInt32? = nil
    var _headIndex: Int32? = nil
    var _headString: String? = nil
    var _nerString: String? = nil
    var _originalRef: Int32? = nil
    var _goldCorefClusterID: Int32? = nil
    var _corefClusterID: Int32? = nil
    var _mentionNum: Int32? = nil
    var _sentNum: Int32? = nil
    var _utter: Int32? = nil
    var _paragraph: Int32? = nil
    var _isSubject: Bool? = nil
    var _isDirectObject: Bool? = nil
    var _isIndirectObject: Bool? = nil
    var _isPrepositionObject: Bool? = nil
    var _hasTwin_p: Bool? = nil
    var _generic: Bool? = nil
    var _isSingleton: Bool? = nil
    var _hasBasicDependency_p: Bool? = nil
    var _hasEnhancedDepenedncy_p: Bool? = nil
    var _hasContextParseTree_p: Bool? = nil
    var _headIndexedWord: Edu_Stanford_Nlp_Pipeline_IndexedWord? = nil
    var _dependingVerb: Edu_Stanford_Nlp_Pipeline_IndexedWord? = nil
    var _headWord: Edu_Stanford_Nlp_Pipeline_IndexedWord? = nil
    var _speakerInfo: Edu_Stanford_Nlp_Pipeline_SpeakerInfo? = nil
    var _sentenceWords: [Edu_Stanford_Nlp_Pipeline_IndexedWord] = []
    var _originalSpan: [Edu_Stanford_Nlp_Pipeline_IndexedWord] = []
    var _dependents: [String] = []
    var _preprocessedTerms: [String] = []
    var _appositions: [Int32] = []
    var _predicateNominatives: [Int32] = []
    var _relativePronouns: [Int32] = []
    var _listMembers: [Int32] = []
    var _belongToLists: [Int32] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _mentionID = source._mentionID
      _mentionType = source._mentionType
      _number = source._number
      _gender = source._gender
      _animacy = source._animacy
      _person = source._person
      _startIndex = source._startIndex
      _endIndex = source._endIndex
      _headIndex = source._headIndex
      _headString = source._headString
      _nerString = source._nerString
      _originalRef = source._originalRef
      _goldCorefClusterID = source._goldCorefClusterID
      _corefClusterID = source._corefClusterID
      _mentionNum = source._mentionNum
      _sentNum = source._sentNum
      _utter = source._utter
      _paragraph = source._paragraph
      _isSubject = source._isSubject
      _isDirectObject = source._isDirectObject
      _isIndirectObject = source._isIndirectObject
      _isPrepositionObject = source._isPrepositionObject
      _hasTwin_p = source._hasTwin_p
      _generic = source._generic
      _isSingleton = source._isSingleton
      _hasBasicDependency_p = source._hasBasicDependency_p
      _hasEnhancedDepenedncy_p = source._hasEnhancedDepenedncy_p
      _hasContextParseTree_p = source._hasContextParseTree_p
      _headIndexedWord = source._headIndexedWord
      _dependingVerb = source._dependingVerb
      _headWord = source._headWord
      _speakerInfo = source._speakerInfo
      _sentenceWords = source._sentenceWords
      _originalSpan = source._originalSpan
      _dependents = source._dependents
      _preprocessedTerms = source._preprocessedTerms
      _appositions = source._appositions
      _predicateNominatives = source._predicateNominatives
      _relativePronouns = source._relativePronouns
      _listMembers = source._listMembers
      _belongToLists = source._belongToLists
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._mentionID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._mentionType) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._number) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._gender) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._animacy) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._person) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._startIndex) }()
        case 9: try { try decoder.decodeSingularUInt32Field(value: &_storage._endIndex) }()
        case 10: try { try decoder.decodeSingularInt32Field(value: &_storage._headIndex) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._headString) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._nerString) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._originalRef) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._goldCorefClusterID) }()
        case 15: try { try decoder.decodeSingularInt32Field(value: &_storage._corefClusterID) }()
        case 16: try { try decoder.decodeSingularInt32Field(value: &_storage._mentionNum) }()
        case 17: try { try decoder.decodeSingularInt32Field(value: &_storage._sentNum) }()
        case 18: try { try decoder.decodeSingularInt32Field(value: &_storage._utter) }()
        case 19: try { try decoder.decodeSingularInt32Field(value: &_storage._paragraph) }()
        case 20: try { try decoder.decodeSingularBoolField(value: &_storage._isSubject) }()
        case 21: try { try decoder.decodeSingularBoolField(value: &_storage._isDirectObject) }()
        case 22: try { try decoder.decodeSingularBoolField(value: &_storage._isIndirectObject) }()
        case 23: try { try decoder.decodeSingularBoolField(value: &_storage._isPrepositionObject) }()
        case 24: try { try decoder.decodeSingularBoolField(value: &_storage._hasTwin_p) }()
        case 25: try { try decoder.decodeSingularBoolField(value: &_storage._generic) }()
        case 26: try { try decoder.decodeSingularBoolField(value: &_storage._isSingleton) }()
        case 27: try { try decoder.decodeSingularBoolField(value: &_storage._hasBasicDependency_p) }()
        case 28: try { try decoder.decodeSingularBoolField(value: &_storage._hasEnhancedDepenedncy_p) }()
        case 29: try { try decoder.decodeSingularBoolField(value: &_storage._hasContextParseTree_p) }()
        case 30: try { try decoder.decodeSingularMessageField(value: &_storage._headIndexedWord) }()
        case 31: try { try decoder.decodeSingularMessageField(value: &_storage._dependingVerb) }()
        case 32: try { try decoder.decodeSingularMessageField(value: &_storage._headWord) }()
        case 33: try { try decoder.decodeSingularMessageField(value: &_storage._speakerInfo) }()
        case 50: try { try decoder.decodeRepeatedMessageField(value: &_storage._sentenceWords) }()
        case 51: try { try decoder.decodeRepeatedMessageField(value: &_storage._originalSpan) }()
        case 52: try { try decoder.decodeRepeatedStringField(value: &_storage._dependents) }()
        case 53: try { try decoder.decodeRepeatedStringField(value: &_storage._preprocessedTerms) }()
        case 54: try { try decoder.decodeRepeatedInt32Field(value: &_storage._appositions) }()
        case 55: try { try decoder.decodeRepeatedInt32Field(value: &_storage._predicateNominatives) }()
        case 56: try { try decoder.decodeRepeatedInt32Field(value: &_storage._relativePronouns) }()
        case 57: try { try decoder.decodeRepeatedInt32Field(value: &_storage._listMembers) }()
        case 58: try { try decoder.decodeRepeatedInt32Field(value: &_storage._belongToLists) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._mentionID {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
      }
      if let v = _storage._mentionType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._number {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if let v = _storage._gender {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
      if let v = _storage._animacy {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      }
      if let v = _storage._person {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      }
      if let v = _storage._startIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
      }
      if let v = _storage._endIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
      }
      if let v = _storage._headIndex {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 10)
      }
      if let v = _storage._headString {
        try visitor.visitSingularStringField(value: v, fieldNumber: 11)
      }
      if let v = _storage._nerString {
        try visitor.visitSingularStringField(value: v, fieldNumber: 12)
      }
      if let v = _storage._originalRef {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 13)
      }
      if let v = _storage._goldCorefClusterID {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 14)
      }
      if let v = _storage._corefClusterID {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 15)
      }
      if let v = _storage._mentionNum {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 16)
      }
      if let v = _storage._sentNum {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 17)
      }
      if let v = _storage._utter {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 18)
      }
      if let v = _storage._paragraph {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 19)
      }
      if let v = _storage._isSubject {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 20)
      }
      if let v = _storage._isDirectObject {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 21)
      }
      if let v = _storage._isIndirectObject {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 22)
      }
      if let v = _storage._isPrepositionObject {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 23)
      }
      if let v = _storage._hasTwin_p {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 24)
      }
      if let v = _storage._generic {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 25)
      }
      if let v = _storage._isSingleton {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 26)
      }
      if let v = _storage._hasBasicDependency_p {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 27)
      }
      if let v = _storage._hasEnhancedDepenedncy_p {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 28)
      }
      if let v = _storage._hasContextParseTree_p {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 29)
      }
      if let v = _storage._headIndexedWord {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      }
      if let v = _storage._dependingVerb {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      }
      if let v = _storage._headWord {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      }
      if let v = _storage._speakerInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      }
      if !_storage._sentenceWords.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._sentenceWords, fieldNumber: 50)
      }
      if !_storage._originalSpan.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._originalSpan, fieldNumber: 51)
      }
      if !_storage._dependents.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._dependents, fieldNumber: 52)
      }
      if !_storage._preprocessedTerms.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._preprocessedTerms, fieldNumber: 53)
      }
      if !_storage._appositions.isEmpty {
        try visitor.visitRepeatedInt32Field(value: _storage._appositions, fieldNumber: 54)
      }
      if !_storage._predicateNominatives.isEmpty {
        try visitor.visitRepeatedInt32Field(value: _storage._predicateNominatives, fieldNumber: 55)
      }
      if !_storage._relativePronouns.isEmpty {
        try visitor.visitRepeatedInt32Field(value: _storage._relativePronouns, fieldNumber: 56)
      }
      if !_storage._listMembers.isEmpty {
        try visitor.visitRepeatedInt32Field(value: _storage._listMembers, fieldNumber: 57)
      }
      if !_storage._belongToLists.isEmpty {
        try visitor.visitRepeatedInt32Field(value: _storage._belongToLists, fieldNumber: 58)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_Mention, rhs: Edu_Stanford_Nlp_Pipeline_Mention) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._mentionID != rhs_storage._mentionID {return false}
        if _storage._mentionType != rhs_storage._mentionType {return false}
        if _storage._number != rhs_storage._number {return false}
        if _storage._gender != rhs_storage._gender {return false}
        if _storage._animacy != rhs_storage._animacy {return false}
        if _storage._person != rhs_storage._person {return false}
        if _storage._startIndex != rhs_storage._startIndex {return false}
        if _storage._endIndex != rhs_storage._endIndex {return false}
        if _storage._headIndex != rhs_storage._headIndex {return false}
        if _storage._headString != rhs_storage._headString {return false}
        if _storage._nerString != rhs_storage._nerString {return false}
        if _storage._originalRef != rhs_storage._originalRef {return false}
        if _storage._goldCorefClusterID != rhs_storage._goldCorefClusterID {return false}
        if _storage._corefClusterID != rhs_storage._corefClusterID {return false}
        if _storage._mentionNum != rhs_storage._mentionNum {return false}
        if _storage._sentNum != rhs_storage._sentNum {return false}
        if _storage._utter != rhs_storage._utter {return false}
        if _storage._paragraph != rhs_storage._paragraph {return false}
        if _storage._isSubject != rhs_storage._isSubject {return false}
        if _storage._isDirectObject != rhs_storage._isDirectObject {return false}
        if _storage._isIndirectObject != rhs_storage._isIndirectObject {return false}
        if _storage._isPrepositionObject != rhs_storage._isPrepositionObject {return false}
        if _storage._hasTwin_p != rhs_storage._hasTwin_p {return false}
        if _storage._generic != rhs_storage._generic {return false}
        if _storage._isSingleton != rhs_storage._isSingleton {return false}
        if _storage._hasBasicDependency_p != rhs_storage._hasBasicDependency_p {return false}
        if _storage._hasEnhancedDepenedncy_p != rhs_storage._hasEnhancedDepenedncy_p {return false}
        if _storage._hasContextParseTree_p != rhs_storage._hasContextParseTree_p {return false}
        if _storage._headIndexedWord != rhs_storage._headIndexedWord {return false}
        if _storage._dependingVerb != rhs_storage._dependingVerb {return false}
        if _storage._headWord != rhs_storage._headWord {return false}
        if _storage._speakerInfo != rhs_storage._speakerInfo {return false}
        if _storage._sentenceWords != rhs_storage._sentenceWords {return false}
        if _storage._originalSpan != rhs_storage._originalSpan {return false}
        if _storage._dependents != rhs_storage._dependents {return false}
        if _storage._preprocessedTerms != rhs_storage._preprocessedTerms {return false}
        if _storage._appositions != rhs_storage._appositions {return false}
        if _storage._predicateNominatives != rhs_storage._predicateNominatives {return false}
        if _storage._relativePronouns != rhs_storage._relativePronouns {return false}
        if _storage._listMembers != rhs_storage._listMembers {return false}
        if _storage._belongToLists != rhs_storage._belongToLists {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Edu_Stanford_Nlp_Pipeline_IndexedWord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IndexedWord"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sentenceNum"),
    2: .same(proto: "tokenIndex"),
    3: .same(proto: "docID"),
    4: .same(proto: "copyCount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._sentenceNum) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._tokenIndex) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._docID) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._copyCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._sentenceNum {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._tokenIndex {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._docID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._copyCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_IndexedWord, rhs: Edu_Stanford_Nlp_Pipeline_IndexedWord) -> Bool {
    if lhs._sentenceNum != rhs._sentenceNum {return false}
    if lhs._tokenIndex != rhs._tokenIndex {return false}
    if lhs._docID != rhs._docID {return false}
    if lhs._copyCount != rhs._copyCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Edu_Stanford_Nlp_Pipeline_SpeakerInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SpeakerInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "speakerName"),
    2: .same(proto: "mentions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._speakerName) }()
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.mentions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._speakerName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if !self.mentions.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.mentions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_SpeakerInfo, rhs: Edu_Stanford_Nlp_Pipeline_SpeakerInfo) -> Bool {
    if lhs._speakerName != rhs._speakerName {return false}
    if lhs.mentions != rhs.mentions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Edu_Stanford_Nlp_Pipeline_Span: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Span"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "begin"),
    2: .same(proto: "end"),
  ]

  public var isInitialized: Bool {
    if self._begin == nil {return false}
    if self._end == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._begin) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._end) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._begin {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._end {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_Span, rhs: Edu_Stanford_Nlp_Pipeline_Span) -> Bool {
    if lhs._begin != rhs._begin {return false}
    if lhs._end != rhs._end {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Edu_Stanford_Nlp_Pipeline_Timex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Timex"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "altValue"),
    3: .same(proto: "text"),
    4: .same(proto: "type"),
    5: .same(proto: "tid"),
    6: .same(proto: "beginPoint"),
    7: .same(proto: "endPoint"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._altValue) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._text) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._type) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._tid) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._beginPoint) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._endPoint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._altValue {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._text {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._type {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._tid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    if let v = self._beginPoint {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    }
    if let v = self._endPoint {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_Timex, rhs: Edu_Stanford_Nlp_Pipeline_Timex) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs._altValue != rhs._altValue {return false}
    if lhs._text != rhs._text {return false}
    if lhs._type != rhs._type {return false}
    if lhs._tid != rhs._tid {return false}
    if lhs._beginPoint != rhs._beginPoint {return false}
    if lhs._endPoint != rhs._endPoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Edu_Stanford_Nlp_Pipeline_Entity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Entity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    6: .same(proto: "headStart"),
    7: .same(proto: "headEnd"),
    8: .same(proto: "mentionType"),
    9: .same(proto: "normalizedName"),
    10: .same(proto: "headTokenIndex"),
    11: .same(proto: "corefID"),
    1: .same(proto: "objectID"),
    2: .same(proto: "extentStart"),
    3: .same(proto: "extentEnd"),
    4: .same(proto: "type"),
    5: .same(proto: "subtype"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._objectID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._extentStart) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._extentEnd) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._type) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._subtype) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._headStart) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._headEnd) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._mentionType) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._normalizedName) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self._headTokenIndex) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self._corefID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._objectID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._extentStart {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._extentEnd {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._type {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._subtype {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    if let v = self._headStart {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    }
    if let v = self._headEnd {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    }
    if let v = self._mentionType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    }
    if let v = self._normalizedName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    }
    if let v = self._headTokenIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
    }
    if let v = self._corefID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_Entity, rhs: Edu_Stanford_Nlp_Pipeline_Entity) -> Bool {
    if lhs._headStart != rhs._headStart {return false}
    if lhs._headEnd != rhs._headEnd {return false}
    if lhs._mentionType != rhs._mentionType {return false}
    if lhs._normalizedName != rhs._normalizedName {return false}
    if lhs._headTokenIndex != rhs._headTokenIndex {return false}
    if lhs._corefID != rhs._corefID {return false}
    if lhs._objectID != rhs._objectID {return false}
    if lhs._extentStart != rhs._extentStart {return false}
    if lhs._extentEnd != rhs._extentEnd {return false}
    if lhs._type != rhs._type {return false}
    if lhs._subtype != rhs._subtype {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Edu_Stanford_Nlp_Pipeline_Relation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Relation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    6: .same(proto: "argName"),
    7: .same(proto: "arg"),
    8: .same(proto: "signature"),
    1: .same(proto: "objectID"),
    2: .same(proto: "extentStart"),
    3: .same(proto: "extentEnd"),
    4: .same(proto: "type"),
    5: .same(proto: "subtype"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._objectID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._extentStart) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._extentEnd) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._type) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._subtype) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.argName) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.arg) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._objectID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._extentStart {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._extentEnd {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._type {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._subtype {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    if !self.argName.isEmpty {
      try visitor.visitRepeatedStringField(value: self.argName, fieldNumber: 6)
    }
    if !self.arg.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.arg, fieldNumber: 7)
    }
    if let v = self._signature {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_Relation, rhs: Edu_Stanford_Nlp_Pipeline_Relation) -> Bool {
    if lhs.argName != rhs.argName {return false}
    if lhs.arg != rhs.arg {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs._objectID != rhs._objectID {return false}
    if lhs._extentStart != rhs._extentStart {return false}
    if lhs._extentEnd != rhs._extentEnd {return false}
    if lhs._type != rhs._type {return false}
    if lhs._subtype != rhs._subtype {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Edu_Stanford_Nlp_Pipeline_Operator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Operator"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "quantifierSpanBegin"),
    3: .same(proto: "quantifierSpanEnd"),
    4: .same(proto: "subjectSpanBegin"),
    5: .same(proto: "subjectSpanEnd"),
    6: .same(proto: "objectSpanBegin"),
    7: .same(proto: "objectSpanEnd"),
  ]

  public var isInitialized: Bool {
    if self._name == nil {return false}
    if self._quantifierSpanBegin == nil {return false}
    if self._quantifierSpanEnd == nil {return false}
    if self._subjectSpanBegin == nil {return false}
    if self._subjectSpanEnd == nil {return false}
    if self._objectSpanBegin == nil {return false}
    if self._objectSpanEnd == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._quantifierSpanBegin) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._quantifierSpanEnd) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._subjectSpanBegin) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._subjectSpanEnd) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self._objectSpanBegin) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self._objectSpanEnd) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._quantifierSpanBegin {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._quantifierSpanEnd {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._subjectSpanBegin {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._subjectSpanEnd {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    }
    if let v = self._objectSpanBegin {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
    }
    if let v = self._objectSpanEnd {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_Operator, rhs: Edu_Stanford_Nlp_Pipeline_Operator) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._quantifierSpanBegin != rhs._quantifierSpanBegin {return false}
    if lhs._quantifierSpanEnd != rhs._quantifierSpanEnd {return false}
    if lhs._subjectSpanBegin != rhs._subjectSpanBegin {return false}
    if lhs._subjectSpanEnd != rhs._subjectSpanEnd {return false}
    if lhs._objectSpanBegin != rhs._objectSpanBegin {return false}
    if lhs._objectSpanEnd != rhs._objectSpanEnd {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Edu_Stanford_Nlp_Pipeline_Polarity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Polarity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "projectEquivalence"),
    2: .same(proto: "projectForwardEntailment"),
    3: .same(proto: "projectReverseEntailment"),
    4: .same(proto: "projectNegation"),
    5: .same(proto: "projectAlternation"),
    6: .same(proto: "projectCover"),
    7: .same(proto: "projectIndependence"),
  ]

  public var isInitialized: Bool {
    if self._projectEquivalence == nil {return false}
    if self._projectForwardEntailment == nil {return false}
    if self._projectReverseEntailment == nil {return false}
    if self._projectNegation == nil {return false}
    if self._projectAlternation == nil {return false}
    if self._projectCover == nil {return false}
    if self._projectIndependence == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._projectEquivalence) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._projectForwardEntailment) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._projectReverseEntailment) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._projectNegation) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self._projectAlternation) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self._projectCover) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self._projectIndependence) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._projectEquivalence {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if let v = self._projectForwardEntailment {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }
    if let v = self._projectReverseEntailment {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }
    if let v = self._projectNegation {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    }
    if let v = self._projectAlternation {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    }
    if let v = self._projectCover {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    }
    if let v = self._projectIndependence {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_Polarity, rhs: Edu_Stanford_Nlp_Pipeline_Polarity) -> Bool {
    if lhs._projectEquivalence != rhs._projectEquivalence {return false}
    if lhs._projectForwardEntailment != rhs._projectForwardEntailment {return false}
    if lhs._projectReverseEntailment != rhs._projectReverseEntailment {return false}
    if lhs._projectNegation != rhs._projectNegation {return false}
    if lhs._projectAlternation != rhs._projectAlternation {return false}
    if lhs._projectCover != rhs._projectCover {return false}
    if lhs._projectIndependence != rhs._projectIndependence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Edu_Stanford_Nlp_Pipeline_NERMention: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NERMention"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sentenceIndex"),
    2: .same(proto: "tokenStartInSentenceInclusive"),
    3: .same(proto: "tokenEndInSentenceExclusive"),
    4: .same(proto: "ner"),
    5: .same(proto: "normalizedNER"),
    6: .same(proto: "entityType"),
    7: .same(proto: "timex"),
    8: .same(proto: "wikipediaEntity"),
    9: .same(proto: "gender"),
    10: .same(proto: "entityMentionIndex"),
    11: .same(proto: "canonicalEntityMentionIndex"),
    12: .same(proto: "entityMentionText"),
  ]

  fileprivate class _StorageClass {
    var _sentenceIndex: UInt32? = nil
    var _tokenStartInSentenceInclusive: UInt32? = nil
    var _tokenEndInSentenceExclusive: UInt32? = nil
    var _ner: String? = nil
    var _normalizedNer: String? = nil
    var _entityType: String? = nil
    var _timex: Edu_Stanford_Nlp_Pipeline_Timex? = nil
    var _wikipediaEntity: String? = nil
    var _gender: String? = nil
    var _entityMentionIndex: UInt32? = nil
    var _canonicalEntityMentionIndex: UInt32? = nil
    var _entityMentionText: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _sentenceIndex = source._sentenceIndex
      _tokenStartInSentenceInclusive = source._tokenStartInSentenceInclusive
      _tokenEndInSentenceExclusive = source._tokenEndInSentenceExclusive
      _ner = source._ner
      _normalizedNer = source._normalizedNer
      _entityType = source._entityType
      _timex = source._timex
      _wikipediaEntity = source._wikipediaEntity
      _gender = source._gender
      _entityMentionIndex = source._entityMentionIndex
      _canonicalEntityMentionIndex = source._canonicalEntityMentionIndex
      _entityMentionText = source._entityMentionText
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._tokenStartInSentenceInclusive == nil {return false}
      if _storage._tokenEndInSentenceExclusive == nil {return false}
      if _storage._ner == nil {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._sentenceIndex) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._tokenStartInSentenceInclusive) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._tokenEndInSentenceExclusive) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._ner) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._normalizedNer) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._entityType) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._timex) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._wikipediaEntity) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._gender) }()
        case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._entityMentionIndex) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._canonicalEntityMentionIndex) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._entityMentionText) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._sentenceIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
      }
      if let v = _storage._tokenStartInSentenceInclusive {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
      }
      if let v = _storage._tokenEndInSentenceExclusive {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
      }
      if let v = _storage._ner {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
      if let v = _storage._normalizedNer {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      }
      if let v = _storage._entityType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      }
      if let v = _storage._timex {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._wikipediaEntity {
        try visitor.visitSingularStringField(value: v, fieldNumber: 8)
      }
      if let v = _storage._gender {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      }
      if let v = _storage._entityMentionIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
      }
      if let v = _storage._canonicalEntityMentionIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 11)
      }
      if let v = _storage._entityMentionText {
        try visitor.visitSingularStringField(value: v, fieldNumber: 12)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_NERMention, rhs: Edu_Stanford_Nlp_Pipeline_NERMention) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sentenceIndex != rhs_storage._sentenceIndex {return false}
        if _storage._tokenStartInSentenceInclusive != rhs_storage._tokenStartInSentenceInclusive {return false}
        if _storage._tokenEndInSentenceExclusive != rhs_storage._tokenEndInSentenceExclusive {return false}
        if _storage._ner != rhs_storage._ner {return false}
        if _storage._normalizedNer != rhs_storage._normalizedNer {return false}
        if _storage._entityType != rhs_storage._entityType {return false}
        if _storage._timex != rhs_storage._timex {return false}
        if _storage._wikipediaEntity != rhs_storage._wikipediaEntity {return false}
        if _storage._gender != rhs_storage._gender {return false}
        if _storage._entityMentionIndex != rhs_storage._entityMentionIndex {return false}
        if _storage._canonicalEntityMentionIndex != rhs_storage._canonicalEntityMentionIndex {return false}
        if _storage._entityMentionText != rhs_storage._entityMentionText {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Edu_Stanford_Nlp_Pipeline_SentenceFragment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SentenceFragment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokenIndex"),
    2: .same(proto: "root"),
    3: .same(proto: "assumedTruth"),
    4: .same(proto: "score"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt32Field(value: &self.tokenIndex) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._root) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._assumedTruth) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self._score) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tokenIndex.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.tokenIndex, fieldNumber: 1)
    }
    if let v = self._root {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._assumedTruth {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    if let v = self._score {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_SentenceFragment, rhs: Edu_Stanford_Nlp_Pipeline_SentenceFragment) -> Bool {
    if lhs.tokenIndex != rhs.tokenIndex {return false}
    if lhs._root != rhs._root {return false}
    if lhs._assumedTruth != rhs._assumedTruth {return false}
    if lhs._score != rhs._score {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Edu_Stanford_Nlp_Pipeline_TokenLocation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenLocation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sentenceIndex"),
    2: .same(proto: "tokenIndex"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._sentenceIndex) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._tokenIndex) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._sentenceIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._tokenIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_TokenLocation, rhs: Edu_Stanford_Nlp_Pipeline_TokenLocation) -> Bool {
    if lhs._sentenceIndex != rhs._sentenceIndex {return false}
    if lhs._tokenIndex != rhs._tokenIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Edu_Stanford_Nlp_Pipeline_RelationTriple: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RelationTriple"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subject"),
    2: .same(proto: "relation"),
    3: .same(proto: "object"),
    4: .same(proto: "confidence"),
    13: .same(proto: "subjectTokens"),
    14: .same(proto: "relationTokens"),
    15: .same(proto: "objectTokens"),
    8: .same(proto: "tree"),
    9: .same(proto: "istmod"),
    10: .same(proto: "prefixBe"),
    11: .same(proto: "suffixBe"),
    12: .same(proto: "suffixOf"),
  ]

  public var isInitialized: Bool {
    if let v = self._tree, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._subject) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._relation) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._object) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self._confidence) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._tree) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self._istmod) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self._prefixBe) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self._suffixBe) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self._suffixOf) }()
      case 13: try { try decoder.decodeRepeatedMessageField(value: &self.subjectTokens) }()
      case 14: try { try decoder.decodeRepeatedMessageField(value: &self.relationTokens) }()
      case 15: try { try decoder.decodeRepeatedMessageField(value: &self.objectTokens) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._subject {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._relation {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._object {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._confidence {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
    }
    if let v = self._tree {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if let v = self._istmod {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
    }
    if let v = self._prefixBe {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
    }
    if let v = self._suffixBe {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
    }
    if let v = self._suffixOf {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
    }
    if !self.subjectTokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.subjectTokens, fieldNumber: 13)
    }
    if !self.relationTokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.relationTokens, fieldNumber: 14)
    }
    if !self.objectTokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.objectTokens, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_RelationTriple, rhs: Edu_Stanford_Nlp_Pipeline_RelationTriple) -> Bool {
    if lhs._subject != rhs._subject {return false}
    if lhs._relation != rhs._relation {return false}
    if lhs._object != rhs._object {return false}
    if lhs._confidence != rhs._confidence {return false}
    if lhs.subjectTokens != rhs.subjectTokens {return false}
    if lhs.relationTokens != rhs.relationTokens {return false}
    if lhs.objectTokens != rhs.objectTokens {return false}
    if lhs._tree != rhs._tree {return false}
    if lhs._istmod != rhs._istmod {return false}
    if lhs._prefixBe != rhs._prefixBe {return false}
    if lhs._suffixBe != rhs._suffixBe {return false}
    if lhs._suffixOf != rhs._suffixOf {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Edu_Stanford_Nlp_Pipeline_MapStringString: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MapStringString"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.key) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitRepeatedStringField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitRepeatedStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_MapStringString, rhs: Edu_Stanford_Nlp_Pipeline_MapStringString) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Edu_Stanford_Nlp_Pipeline_MapIntString: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MapIntString"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt32Field(value: &self.key) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitRepeatedStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_MapIntString, rhs: Edu_Stanford_Nlp_Pipeline_MapIntString) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Edu_Stanford_Nlp_Pipeline_Section: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Section"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "charBegin"),
    2: .same(proto: "charEnd"),
    3: .same(proto: "author"),
    4: .same(proto: "sentenceIndexes"),
    5: .same(proto: "datetime"),
    6: .same(proto: "quotes"),
    7: .same(proto: "authorCharBegin"),
    8: .same(proto: "authorCharEnd"),
    9: .same(proto: "xmlTag"),
  ]

  public var isInitialized: Bool {
    if self._charBegin == nil {return false}
    if self._charEnd == nil {return false}
    if self._xmlTag == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.quotes) {return false}
    if let v = self._xmlTag, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._charBegin) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._charEnd) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._author) }()
      case 4: try { try decoder.decodeRepeatedUInt32Field(value: &self.sentenceIndexes) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._datetime) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.quotes) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._authorCharBegin) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self._authorCharEnd) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._xmlTag) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._charBegin {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._charEnd {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._author {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if !self.sentenceIndexes.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.sentenceIndexes, fieldNumber: 4)
    }
    if let v = self._datetime {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    if !self.quotes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.quotes, fieldNumber: 6)
    }
    if let v = self._authorCharBegin {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    }
    if let v = self._authorCharEnd {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
    }
    if let v = self._xmlTag {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_Section, rhs: Edu_Stanford_Nlp_Pipeline_Section) -> Bool {
    if lhs._charBegin != rhs._charBegin {return false}
    if lhs._charEnd != rhs._charEnd {return false}
    if lhs._author != rhs._author {return false}
    if lhs.sentenceIndexes != rhs.sentenceIndexes {return false}
    if lhs._datetime != rhs._datetime {return false}
    if lhs.quotes != rhs.quotes {return false}
    if lhs._authorCharBegin != rhs._authorCharBegin {return false}
    if lhs._authorCharEnd != rhs._authorCharEnd {return false}
    if lhs._xmlTag != rhs._xmlTag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Edu_Stanford_Nlp_Pipeline_SemgrexRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SemgrexRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "semgrex"),
    2: .same(proto: "query"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.query) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.semgrex) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.query) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.semgrex.isEmpty {
      try visitor.visitRepeatedStringField(value: self.semgrex, fieldNumber: 1)
    }
    if !self.query.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.query, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_SemgrexRequest, rhs: Edu_Stanford_Nlp_Pipeline_SemgrexRequest) -> Bool {
    if lhs.semgrex != rhs.semgrex {return false}
    if lhs.query != rhs.query {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Edu_Stanford_Nlp_Pipeline_SemgrexRequest.Dependencies: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Edu_Stanford_Nlp_Pipeline_SemgrexRequest.protoMessageName + ".Dependencies"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "graph"),
  ]

  public var isInitialized: Bool {
    if self._graph == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.token) {return false}
    if let v = self._graph, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.token) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._graph) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.token, fieldNumber: 1)
    }
    if let v = self._graph {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_SemgrexRequest.Dependencies, rhs: Edu_Stanford_Nlp_Pipeline_SemgrexRequest.Dependencies) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs._graph != rhs._graph {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Edu_Stanford_Nlp_Pipeline_SemgrexResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SemgrexResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.result) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.result.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_SemgrexResponse, rhs: Edu_Stanford_Nlp_Pipeline_SemgrexResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Edu_Stanford_Nlp_Pipeline_SemgrexResponse.NamedNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Edu_Stanford_Nlp_Pipeline_SemgrexResponse.protoMessageName + ".NamedNode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "matchIndex"),
  ]

  public var isInitialized: Bool {
    if self._name == nil {return false}
    if self._matchIndex == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._matchIndex) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._matchIndex {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_SemgrexResponse.NamedNode, rhs: Edu_Stanford_Nlp_Pipeline_SemgrexResponse.NamedNode) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._matchIndex != rhs._matchIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Edu_Stanford_Nlp_Pipeline_SemgrexResponse.NamedRelation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Edu_Stanford_Nlp_Pipeline_SemgrexResponse.protoMessageName + ".NamedRelation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "reln"),
  ]

  public var isInitialized: Bool {
    if self._name == nil {return false}
    if self._reln == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._reln) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._reln {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_SemgrexResponse.NamedRelation, rhs: Edu_Stanford_Nlp_Pipeline_SemgrexResponse.NamedRelation) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._reln != rhs._reln {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Edu_Stanford_Nlp_Pipeline_SemgrexResponse.Match: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Edu_Stanford_Nlp_Pipeline_SemgrexResponse.protoMessageName + ".Match"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "matchIndex"),
    2: .same(proto: "node"),
    3: .same(proto: "reln"),
  ]

  public var isInitialized: Bool {
    if self._matchIndex == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.node) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.reln) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._matchIndex) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.node) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.reln) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._matchIndex {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if !self.node.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.node, fieldNumber: 2)
    }
    if !self.reln.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reln, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_SemgrexResponse.Match, rhs: Edu_Stanford_Nlp_Pipeline_SemgrexResponse.Match) -> Bool {
    if lhs._matchIndex != rhs._matchIndex {return false}
    if lhs.node != rhs.node {return false}
    if lhs.reln != rhs.reln {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Edu_Stanford_Nlp_Pipeline_SemgrexResponse.SemgrexResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Edu_Stanford_Nlp_Pipeline_SemgrexResponse.protoMessageName + ".SemgrexResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "match"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.match) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.match) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.match.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.match, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_SemgrexResponse.SemgrexResult, rhs: Edu_Stanford_Nlp_Pipeline_SemgrexResponse.SemgrexResult) -> Bool {
    if lhs.match != rhs.match {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Edu_Stanford_Nlp_Pipeline_SemgrexResponse.GraphResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Edu_Stanford_Nlp_Pipeline_SemgrexResponse.protoMessageName + ".GraphResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.result) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.result.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_SemgrexResponse.GraphResult, rhs: Edu_Stanford_Nlp_Pipeline_SemgrexResponse.GraphResult) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Edu_Stanford_Nlp_Pipeline_TokensRegexRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokensRegexRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "doc"),
    2: .same(proto: "pattern"),
  ]

  public var isInitialized: Bool {
    if self._doc == nil {return false}
    if let v = self._doc, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._doc) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.pattern) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._doc {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.pattern.isEmpty {
      try visitor.visitRepeatedStringField(value: self.pattern, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_TokensRegexRequest, rhs: Edu_Stanford_Nlp_Pipeline_TokensRegexRequest) -> Bool {
    if lhs._doc != rhs._doc {return false}
    if lhs.pattern != rhs.pattern {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Edu_Stanford_Nlp_Pipeline_TokensRegexResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokensRegexResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "match"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.match) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.match) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.match.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.match, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_TokensRegexResponse, rhs: Edu_Stanford_Nlp_Pipeline_TokensRegexResponse) -> Bool {
    if lhs.match != rhs.match {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Edu_Stanford_Nlp_Pipeline_TokensRegexResponse.MatchLocation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Edu_Stanford_Nlp_Pipeline_TokensRegexResponse.protoMessageName + ".MatchLocation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "begin"),
    3: .same(proto: "end"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._text) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._begin) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._end) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._text {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._begin {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._end {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_TokensRegexResponse.MatchLocation, rhs: Edu_Stanford_Nlp_Pipeline_TokensRegexResponse.MatchLocation) -> Bool {
    if lhs._text != rhs._text {return false}
    if lhs._begin != rhs._begin {return false}
    if lhs._end != rhs._end {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Edu_Stanford_Nlp_Pipeline_TokensRegexResponse.Match: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Edu_Stanford_Nlp_Pipeline_TokensRegexResponse.protoMessageName + ".Match"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sentence"),
    2: .same(proto: "match"),
    3: .same(proto: "group"),
  ]

  public var isInitialized: Bool {
    if self._sentence == nil {return false}
    if self._match == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._sentence) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._match) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.group) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._sentence {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._match {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.group.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.group, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_TokensRegexResponse.Match, rhs: Edu_Stanford_Nlp_Pipeline_TokensRegexResponse.Match) -> Bool {
    if lhs._sentence != rhs._sentence {return false}
    if lhs._match != rhs._match {return false}
    if lhs.group != rhs.group {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Edu_Stanford_Nlp_Pipeline_TokensRegexResponse.PatternMatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Edu_Stanford_Nlp_Pipeline_TokensRegexResponse.protoMessageName + ".PatternMatch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "match"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.match) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.match) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.match.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.match, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Edu_Stanford_Nlp_Pipeline_TokensRegexResponse.PatternMatch, rhs: Edu_Stanford_Nlp_Pipeline_TokensRegexResponse.PatternMatch) -> Bool {
    if lhs.match != rhs.match {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
